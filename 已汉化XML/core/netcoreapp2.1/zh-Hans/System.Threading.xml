<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Threading</name>
  </assembly>
  <members>
    <member name="T:System.Threading.ThreadLocal`1">
      <summary>
              提供数据的线程本地存储。
            </summary>
      <typeparam name="T">
                指定按线程存储的数据类型。
              </typeparam>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor">
      <summary>
              初始化 <see cref="T:System.Threading.ThreadLocal`1" /> 实例。
            </summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Boolean)">
      <summary>
              初始化 <see cref="T:System.Threading.ThreadLocal`1" /> 实例，并指定所有值都是否可从任意线程访问。
            </summary>
      <param name="trackAllValues">
        <see langword="true" /> 若要跟踪的实例上的所有设置的值并将它们通过公开 <see cref="P:System.Threading.ThreadLocal`1.Values" /> 属性; <see langword="false" /> 否则为。
              </param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0})">
      <summary>
              初始化 <see cref="T:System.Threading.ThreadLocal`1" /> 实例与指定 <paramref name="valueFactory" /> 函数。
            </summary>
      <param name="valueFactory">
        <see cref="T:System.Func`1" /> 调用以产生延迟初始化的值，当尝试检索 <see cref="P:System.Threading.ThreadLocal`1.Value" /> 没有它具有先前已初始化。
              </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="valueFactory" /> 为 null 引用（在 Visual Basic 中为 Nothing）。
                </exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.#ctor(System.Func{`0},System.Boolean)">
      <summary>
              初始化 <see cref="T:System.Threading.ThreadLocal`1" /> 实例与指定 <paramref name="valueFactory" /> 函数和一个标志，指示是否所有值都都可以从任意线程访问。
            </summary>
      <param name="valueFactory">
        <see cref="T:System.Func`1" /> 调用以产生延迟初始化的值，当尝试检索 <see cref="P:System.Threading.ThreadLocal`1.Value" /> 没有它具有先前已初始化。
              </param>
      <param name="trackAllValues">
        <see langword="true" /> 若要跟踪的实例上的所有设置的值并将它们通过公开 <see cref="P:System.Threading.ThreadLocal`1.Values" /> 属性; <see langword="false" /> 否则为。
              </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="valueFactory" /> 为 <see langword="null" /> 引用（在 Visual Basic 中为 <see langword="Nothing" />）。
                </exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose">
      <summary>
              释放 <see cref="T:System.Threading.ThreadLocal`1" /> 类的当前实例所使用的所有资源。
            </summary>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Dispose(System.Boolean)">
      <summary>
              释放由该使用的资源 <see cref="T:System.Threading.ThreadLocal`1" /> 实例。
            </summary>
      <param name="disposing">
                一个布尔值，该值指示是否由于调用 <see cref="M:System.Threading.ThreadLocal`1.Dispose" /> 的原因而调用此方法。
              </param>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.Finalize">
      <summary>
              释放由该使用的资源 <see cref="T:System.Threading.ThreadLocal`1" /> 实例。
            </summary>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.IsValueCreated">
      <summary>
              获取是否 <see cref="P:System.Threading.ThreadLocal`1.Value" /> 初始化当前线程上。
            </summary>
      <returns>
              true <see cref="P:System.Threading.ThreadLocal`1.Value" /> 在当前线程上初始化; 否则为 false。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ThreadLocal`1" /> 释放实例。
                </exception>
    </member>
    <member name="M:System.Threading.ThreadLocal`1.ToString">
      <summary>
              创建并返回当前线程在此实例的字符串表示。
            </summary>
      <returns>
              因调用 <see cref="M:System.Object.ToString" /> 上 <see cref="P:System.Threading.ThreadLocal`1.Value" />。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ThreadLocal`1" /> 释放实例。
                </exception>
      <exception cref="T:System.NullReferenceException">
        <see cref="P:System.Threading.ThreadLocal`1.Value" /> 当前线程是空引用 (在 Visual Basic 中为 Nothing)。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  初始化函数试图引用 <see cref="P:System.Threading.ThreadLocal`1.Value" /> 以递归方式。
                </exception>
      <exception cref="T:System.MissingMemberException">
                  没有默认构造函数提供，并不提供任何值工厂。
                </exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Value">
      <summary>
              获取或设置当前线程在此实例的值。
            </summary>
      <returns>
              返回此 ThreadLocal 负责初始化对象的实例。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  已释放了 <see cref="T:System.Threading.ThreadLocal`1" /> 实例。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  初始化函数试图引用 <see cref="P:System.Threading.ThreadLocal`1.Value" /> 以递归方式。
                </exception>
      <exception cref="T:System.MissingMemberException">
                  没有默认构造函数提供，并不提供任何值工厂。
                </exception>
    </member>
    <member name="P:System.Threading.ThreadLocal`1.Values">
      <summary>
              获取所有由所有已访问此实例的线程当前存储的值列表。
            </summary>
      <returns>
              所有由所有已访问此实例的线程当前存储的值列表。
            </returns>
      <exception cref="T:System.InvalidOperationException">
                  所有线程所都存储值不可用，因为此实例使用初始化 <paramref name="trackAllValues" /> 参数设置为 <see langword="false" /> 给类构造函数调用中。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  已释放了 <see cref="T:System.Threading.ThreadLocal`1" /> 实例。
                </exception>
    </member>
    <member name="T:System.Threading.Volatile">
      <summary>
              包含用于执行可变内存操作的方法。
            </summary>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Boolean@)">
      <summary>
              读取指定字段的值。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 如果执行读 / 写出现之后此方法在代码中，处理器不能将其移动此方法之前。
            </summary>
      <param name="location">
                要读取的字段。
              </param>
      <returns>
              读取的值。
               此值是由在计算机中，而不考虑处理器的数目或处理器缓存的状态的任何处理器写入的最新。
            </returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Byte@)">
      <summary>
              读取指定字段的值。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 如果执行读 / 写出现之后此方法在代码中，处理器不能将其移动此方法之前。
            </summary>
      <param name="location">
                要读取的字段。
              </param>
      <returns>
              读取的值。
               此值是由在计算机中，而不考虑处理器的数目或处理器缓存的状态的任何处理器写入的最新。
            </returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Double@)">
      <summary>
              读取指定字段的值。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 如果执行读 / 写出现之后此方法在代码中，处理器不能将其移动此方法之前。
            </summary>
      <param name="location">
                要读取的字段。
              </param>
      <returns>
              读取的值。
               此值是由在计算机中，而不考虑处理器的数目或处理器缓存的状态的任何处理器写入的最新。
            </returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int16@)">
      <summary>
              读取指定字段的值。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 如果执行读 / 写出现之后此方法在代码中，处理器不能将其移动此方法之前。
            </summary>
      <param name="location">
                要读取的字段。
              </param>
      <returns>
              读取的值。
               此值是由在计算机中，而不考虑处理器的数目或处理器缓存的状态的任何处理器写入的最新。
            </returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int32@)">
      <summary>
              读取指定字段的值。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 如果执行读 / 写出现之后此方法在代码中，处理器不能将其移动此方法之前。
            </summary>
      <param name="location">
                要读取的字段。
              </param>
      <returns>
              读取的值。
               此值是由在计算机中，而不考虑处理器的数目或处理器缓存的状态的任何处理器写入的最新。
            </returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Int64@)">
      <summary>
              读取指定字段的值。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 如果执行读 / 写出现之后此方法在代码中，处理器不能将其移动此方法之前。
            </summary>
      <param name="location">
                要读取的字段。
              </param>
      <returns>
              读取的值。
               此值是由在计算机中，而不考虑处理器的数目或处理器缓存的状态的任何处理器写入的最新。
            </returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.IntPtr@)">
      <summary>
              读取指定字段的值。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 如果执行读 / 写出现之后此方法在代码中，处理器不能将其移动此方法之前。
            </summary>
      <param name="location">
                要读取的字段。
              </param>
      <returns>
              读取的值。
               此值是由在计算机中，而不考虑处理器的数目或处理器缓存的状态的任何处理器写入的最新。
            </returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.SByte@)">
      <summary>
              读取指定字段的值。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 如果执行读 / 写出现之后此方法在代码中，处理器不能将其移动此方法之前。
            </summary>
      <param name="location">
                要读取的字段。
              </param>
      <returns>
              读取的值。
               此值是由在计算机中，而不考虑处理器的数目或处理器缓存的状态的任何处理器写入的最新。
            </returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.Single@)">
      <summary>
              读取指定字段的值。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 如果执行读 / 写出现之后此方法在代码中，处理器不能将其移动此方法之前。
            </summary>
      <param name="location">
                要读取的字段。
              </param>
      <returns>
              读取的值。
               此值是由在计算机中，而不考虑处理器的数目或处理器缓存的状态的任何处理器写入的最新。
            </returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt16@)">
      <summary>
              读取指定字段的值。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 如果执行读 / 写出现之后此方法在代码中，处理器不能将其移动此方法之前。
            </summary>
      <param name="location">
                要读取的字段。
              </param>
      <returns>
              读取的值。
               此值是由在计算机中，而不考虑处理器的数目或处理器缓存的状态的任何处理器写入的最新。
            </returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt32@)">
      <summary>
              读取指定字段的值。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 如果执行读 / 写出现之后此方法在代码中，处理器不能将其移动此方法之前。
            </summary>
      <param name="location">
                要读取的字段。
              </param>
      <returns>
              读取的值。
               此值是由在计算机中，而不考虑处理器的数目或处理器缓存的状态的任何处理器写入的最新。
            </returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UInt64@)">
      <summary>
              读取指定字段的值。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 如果执行读 / 写出现之后此方法在代码中，处理器不能将其移动此方法之前。
            </summary>
      <param name="location">
                要读取的字段。
              </param>
      <returns>
              读取的值。
               此值是由在计算机中，而不考虑处理器的数目或处理器缓存的状态的任何处理器写入的最新。
            </returns>
    </member>
    <member name="M:System.Threading.Volatile.Read(System.UIntPtr@)">
      <summary>
              读取指定字段的值。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 如果执行读 / 写出现之后此方法在代码中，处理器不能将其移动此方法之前。
            </summary>
      <param name="location">
                要读取的字段。
              </param>
      <returns>
              读取的值。
               此值是由在计算机中，而不考虑处理器的数目或处理器缓存的状态的任何处理器写入的最新。
            </returns>
    </member>
    <member name="M:System.Threading.Volatile.Read``1(``0@)">
      <summary>
              从指定的字段中读取的对象引用。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 如果执行读 / 写出现之后此方法在代码中，处理器不能将其移动此方法之前。
            </summary>
      <param name="location">
                要读取的字段。
              </param>
      <typeparam name="T">
                要读取的字段的类型。
                 这必须是引用类型，而不是值类型。
              </typeparam>
      <returns>
              对引用 <paramref name="T" /> 读取。
               此引用是由在计算机中，而不考虑处理器的数目或处理器缓存的状态的任何处理器写入的最新。
            </returns>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Boolean@,System.Boolean)">
      <summary>
              将指定的值写入指定的字段。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 读取或写入出现在此方法在代码中之前，如果处理器不能后将其移动此方法。
            </summary>
      <param name="location">
                该值被写入该字段。
              </param>
      <param name="value">
                要写入的值。
                 立即写入的值，以便的计算机中的所有处理器都可见。
              </param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Byte@,System.Byte)">
      <summary>
              将指定的值写入指定的字段。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 读取或写入出现在此方法在代码中之前，如果处理器不能后将其移动此方法。
            </summary>
      <param name="location">
                该值被写入该字段。
              </param>
      <param name="value">
                要写入的值。
                 立即写入的值，以便的计算机中的所有处理器都可见。
              </param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Double@,System.Double)">
      <summary>
              将指定的值写入指定的字段。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 读取或写入出现在此方法在代码中之前，如果处理器不能后将其移动此方法。
            </summary>
      <param name="location">
                该值被写入该字段。
              </param>
      <param name="value">
                要写入的值。
                 立即写入的值，以便的计算机中的所有处理器都可见。
              </param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int16@,System.Int16)">
      <summary>
              将指定的值写入指定的字段。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 读取或写入出现在此方法在代码中之前，如果处理器不能后将其移动此方法。
            </summary>
      <param name="location">
                该值被写入该字段。
              </param>
      <param name="value">
                要写入的值。
                 立即写入的值，以便的计算机中的所有处理器都可见。
              </param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int32@,System.Int32)">
      <summary>
              将指定的值写入指定的字段。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 读取或写入出现在此方法在代码中之前，如果处理器不能后将其移动此方法。
            </summary>
      <param name="location">
                该值被写入该字段。
              </param>
      <param name="value">
                要写入的值。
                 立即写入的值，以便的计算机中的所有处理器都可见。
              </param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Int64@,System.Int64)">
      <summary>
              将指定的值写入指定的字段。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 内存操作出现在此方法在代码中之前，如果处理器不能后将其移动此方法。
            </summary>
      <param name="location">
                该值被写入该字段。
              </param>
      <param name="value">
                要写入的值。
                 立即写入的值，以便的计算机中的所有处理器都可见。
              </param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.IntPtr@,System.IntPtr)">
      <summary>
              将指定的值写入指定的字段。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 读取或写入出现在此方法在代码中之前，如果处理器不能后将其移动此方法。
            </summary>
      <param name="location">
                该值被写入该字段。
              </param>
      <param name="value">
                要写入的值。
                 立即写入的值，以便的计算机中的所有处理器都可见。
              </param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.SByte@,System.SByte)">
      <summary>
              将指定的值写入指定的字段。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 读取或写入出现在此方法在代码中之前，如果处理器不能后将其移动此方法。
            </summary>
      <param name="location">
                该值被写入该字段。
              </param>
      <param name="value">
                要写入的值。
                 立即写入的值，以便的计算机中的所有处理器都可见。
              </param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.Single@,System.Single)">
      <summary>
              将指定的值写入指定的字段。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 读取或写入出现在此方法在代码中之前，如果处理器不能后将其移动此方法。
            </summary>
      <param name="location">
                该值被写入该字段。
              </param>
      <param name="value">
                要写入的值。
                 立即写入的值，以便的计算机中的所有处理器都可见。
              </param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt16@,System.UInt16)">
      <summary>
              将指定的值写入指定的字段。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 读取或写入出现在此方法在代码中之前，如果处理器不能后将其移动此方法。
            </summary>
      <param name="location">
                该值被写入该字段。
              </param>
      <param name="value">
                要写入的值。
                 立即写入的值，以便的计算机中的所有处理器都可见。
              </param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt32@,System.UInt32)">
      <summary>
              将指定的值写入指定的字段。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 读取或写入出现在此方法在代码中之前，如果处理器不能后将其移动此方法。
            </summary>
      <param name="location">
                该值被写入该字段。
              </param>
      <param name="value">
                要写入的值。
                 立即写入的值，以便的计算机中的所有处理器都可见。
              </param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UInt64@,System.UInt64)">
      <summary>
              将指定的值写入指定的字段。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 读取或写入出现在此方法在代码中之前，如果处理器不能后将其移动此方法。
            </summary>
      <param name="location">
                该值被写入该字段。
              </param>
      <param name="value">
                要写入的值。
                 立即写入的值，以便的计算机中的所有处理器都可见。
              </param>
    </member>
    <member name="M:System.Threading.Volatile.Write(System.UIntPtr@,System.UIntPtr)">
      <summary>
              将指定的值写入指定的字段。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 读取或写入出现在此方法在代码中之前，如果处理器不能后将其移动此方法。
            </summary>
      <param name="location">
                该值被写入该字段。
              </param>
      <param name="value">
                要写入的值。
                 立即写入的值，以便的计算机中的所有处理器都可见。
              </param>
    </member>
    <member name="M:System.Threading.Volatile.Write``1(``0@,``0)">
      <summary>
              将指定的对象引用写入指定的字段。
               在系统上需要它，将插入一个内存屏障，防止处理器对内存操作重新排序，如下所示︰ 读取或写入出现在此方法在代码中之前，如果处理器不能后将其移动此方法。
            </summary>
      <param name="location">
                对象引用的写入位置字段。
              </param>
      <param name="value">
                要写入的对象引用。
                 以便的计算机中的所有处理器都可见，将立即写入该引用。
              </param>
      <typeparam name="T">
                要写入的字段的类型。
                 这必须是引用类型，而不是值类型。
              </typeparam>
    </member>
    <member name="T:System.Threading.WaitHandleCannotBeOpenedException">
      <summary>
              当尝试打开的系统 mutex、 信号量或事件等待句柄不存在时引发的异常。
            </summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor">
      <summary>
              使用默认值初始化 <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> 类的新实例。
            </summary>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String)">
      <summary>
              用指定的错误消息初始化 <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> 类的新实例。
            </summary>
      <param name="message">
                解释异常原因的错误消息。
              </param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              用序列化数据初始化 <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> 类的新实例。
            </summary>
      <param name="info">
                存放有关所引发异常的序列化对象数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象。
              </param>
      <param name="context">
        <see cref="T:System.Runtime.Serialization.StreamingContext" /> 对象，它包含有关源或目标的上下文信息。
              </param>
    </member>
    <member name="M:System.Threading.WaitHandleCannotBeOpenedException.#ctor(System.String,System.Exception)">
      <summary>
              使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.Threading.WaitHandleCannotBeOpenedException" /> 类的新实例。
            </summary>
      <param name="message">
                解释异常原因的错误消息。
              </param>
      <param name="innerException">
                导致当前异常的异常。
                 如果 <paramref name="innerException" /> 参数不为 <see langword="null" />，则当前异常将在处理内部异常的 <see langword="catch" /> 块中引发。
              </param>
    </member>
    <member name="T:System.Threading.AbandonedMutexException">
      <summary>
              当某个线程获取时引发的异常 <see cref="T:System.Threading.Mutex" /> 对象的另一个线程已放弃由正在退出而不将其释放。
            </summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor">
      <summary>
              使用默认值初始化 <see cref="T:System.Threading.AbandonedMutexException" /> 类的新实例。
            </summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String)">
      <summary>
              用指定的错误消息初始化 <see cref="T:System.Threading.AbandonedMutexException" /> 类的新实例。
            </summary>
      <param name="message">
                解释异常原因的错误消息。
              </param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Int32,System.Threading.WaitHandle)">
      <summary>
              新实例初始化 <see cref="T:System.Threading.AbandonedMutexException" /> 类放弃的互斥体的指定索引，如果适用，并且 <see cref="T:System.Threading.Mutex" /> 表示互斥体的对象。
            </summary>
      <param name="location">
                如果引发该异常处理放弃的 mutex 等待数组中的索引 <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> 方法，则返回 – 1 如果引发该异常 <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> 或 <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> 方法。
              </param>
      <param name="handle">
                一个 <see cref="T:System.Threading.Mutex" /> 表示放弃的 mutex 对象。
              </param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              用序列化数据初始化 <see cref="T:System.Threading.AbandonedMutexException" /> 类的新实例。
            </summary>
      <param name="info">
                存放有关所引发异常的序列化对象数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象。
              </param>
      <param name="context">
        <see cref="T:System.Runtime.Serialization.StreamingContext" /> 对象，它包含有关源或目标的上下文信息。
              </param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception)">
      <summary>
              新实例初始化 <see cref="T:System.Threading.AbandonedMutexException" /> 具有指定的错误消息和内部异常类。
            </summary>
      <param name="message">
                解释异常原因的错误消息。
              </param>
      <param name="inner">
                导致当前异常的异常。
                 如果 <paramref name="inner" /> 参数不为 <see langword="null" />，则当前异常将在处理内部异常的 <see langword="catch" /> 块中引发。
              </param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Int32,System.Threading.WaitHandle)">
      <summary>
              新实例初始化 <see cref="T:System.Threading.AbandonedMutexException" /> 类用指定的错误消息时，放弃的 mutex，如果合适的话和放弃的 mutex 的索引。
            </summary>
      <param name="message">
                解释异常原因的错误消息。
              </param>
      <param name="location">
                如果引发该异常处理的等待数组中放弃的 mutex 索引 <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> 方法，则返回 – 1 如果引发该异常 <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> 或 <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> 方法。
              </param>
      <param name="handle">
                一个 <see cref="T:System.Threading.Mutex" /> 表示放弃的 mutex 对象。
              </param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception,System.Int32,System.Threading.WaitHandle)">
      <summary>
              新实例初始化 <see cref="T:System.Threading.AbandonedMutexException" /> 类使用指定的错误消息、 内部异常、 放弃的 mutex 的索引，如果适用，并且 <see cref="T:System.Threading.Mutex" /> 表示互斥体的对象。
            </summary>
      <param name="message">
                解释异常原因的错误消息。
              </param>
      <param name="inner">
                导致当前异常的异常。
                 如果 <paramref name="inner" /> 参数不为 <see langword="null" />，则当前异常将在处理内部异常的 <see langword="catch" /> 块中引发。
              </param>
      <param name="location">
                如果引发该异常处理放弃的 mutex 等待数组中的索引 <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> 方法，则返回 – 1 如果引发该异常 <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> 或 <see cref="Overload:System.Threading.WaitHandle.WaitAll" /> 方法。
              </param>
      <param name="handle">
                一个 <see cref="T:System.Threading.Mutex" /> 表示放弃的 mutex 对象。
              </param>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.Mutex">
      <summary>
              获取导致异常，放弃的 mutex，如果已知。
            </summary>
      <returns>
              一个 <see cref="T:System.Threading.Mutex" /> 对象，表示放弃的 mutex 或 <see langword="null" /> 如果放弃的 mutex 无法识别。
            </returns>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.MutexIndex">
      <summary>
              获取导致异常，放弃的 mutex 的索引，如果已知。
            </summary>
      <returns>
              中的等待句柄数组的索引传递给 <see cref="Overload:System.Threading.WaitHandle.WaitAny" /> 方法的 <see cref="T:System.Threading.Mutex" /> 对象，表示放弃的 mutex，则返回 – 1，如果无法确定放弃的 mutex 的索引。
            </returns>
    </member>
    <member name="T:System.Threading.AsyncFlowControl">
      <summary>
              提供功能以还原执行上下文在线程之间的迁移（或流动）。
            </summary>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Dispose">
      <summary>
              释放 <see cref="T:System.Threading.AsyncFlowControl" /> 类的当前实例所使用的所有资源。
            </summary>
      <exception cref="T:System.InvalidOperationException">
        <see cref="T:System.Threading.AsyncFlowControl" /> 结构未使用的线程上创建它。
                
                  - 或 -
                
                  <see cref="T:System.Threading.AsyncFlowControl" /> 结构具有用于调用 <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> 或 <see cref="M:System.Threading.AsyncFlowControl.Undo" />。
                </exception>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Object)">
      <summary>
              确定指定的对象是否等于当前 <see cref="T:System.Threading.AsyncFlowControl" /> 结构。
            </summary>
      <param name="obj">
                要与当前结构进行比较的对象。
              </param>
      <returns>
        <see langword="true" /> 如果 <paramref name="obj" /> 是 <see cref="T:System.Threading.AsyncFlowControl" /> 结构并且等于当前 <see cref="T:System.Threading.AsyncFlowControl" /> 结构; 否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Equals(System.Threading.AsyncFlowControl)">
      <summary>
              确定是否指定 <see cref="T:System.Threading.AsyncFlowControl" /> 结构是否等于当前 <see cref="T:System.Threading.AsyncFlowControl" /> 结构。
            </summary>
      <param name="obj">
        <see cref="T:System.Threading.AsyncFlowControl" /> 结构要与当前结构进行比较。
              </param>
      <returns>
        <see langword="true" /> 如果 <paramref name="obj" /> 是否等于当前 <see cref="T:System.Threading.AsyncFlowControl" /> 结构; 否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.GetHashCode">
      <summary>
              获取当前的哈希代码 <see cref="T:System.Threading.AsyncFlowControl" /> 结构。
            </summary>
      <returns>
              当前的哈希代码 <see cref="T:System.Threading.AsyncFlowControl" /> 结构。
            </returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Equality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary>
              比较两个 <see cref="T:System.Threading.AsyncFlowControl" /> 结构以确定它们是否相等。
            </summary>
      <param name="a">
        <see cref="T:System.Threading.AsyncFlowControl" /> 结构。
              </param>
      <param name="b">
        <see cref="T:System.Threading.AsyncFlowControl" /> 结构。
              </param>
      <returns>
        <see langword="true" /> 如果两个结构相等，则否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.op_Inequality(System.Threading.AsyncFlowControl,System.Threading.AsyncFlowControl)">
      <summary>
              比较两个 <see cref="T:System.Threading.AsyncFlowControl" /> 结构以确定它们是否不相等。
            </summary>
      <param name="a">
        <see cref="T:System.Threading.AsyncFlowControl" /> 结构。
              </param>
      <param name="b">
        <see cref="T:System.Threading.AsyncFlowControl" /> 结构。
              </param>
      <returns>
              如果两个结构不相等，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="M:System.Threading.AsyncFlowControl.Undo">
      <summary>
              还原执行上下文在线程之间的流动。
            </summary>
      <exception cref="T:System.InvalidOperationException">
        <see cref="T:System.Threading.AsyncFlowControl" /> 结构未使用的线程上创建它。
                
                  - 或 -
                
                  <see cref="T:System.Threading.AsyncFlowControl" /> 结构具有用于调用 <see cref="M:System.Threading.AsyncFlowControl.Dispose" /> 或 <see cref="M:System.Threading.AsyncFlowControl.Undo" />。
                </exception>
    </member>
    <member name="T:System.Threading.AsyncLocal`1">
      <summary>
              表示对于给定异步控制流（如异步方法）是本地数据的环境数据。
            </summary>
      <typeparam name="T">
                环境数据的类型。
              </typeparam>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor">
      <summary>
              实例化不接收更改通知的 <see cref="T:System.Threading.AsyncLocal`1" /> 实例。
            </summary>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor(System.Action{System.Threading.AsyncLocalValueChangedArgs{`0}})">
      <summary>
              实例化接收更改通知的 <see cref="T:System.Threading.AsyncLocal`1" /> 本地实例。
            </summary>
      <param name="valueChangedHandler">
                只要当前值在任何线程上发生更改时便会调用的委托。
              </param>
    </member>
    <member name="P:System.Threading.AsyncLocal`1.Value">
      <summary>
              获取或设置环境数据的值。
            </summary>
      <returns>
              环境数据的值。
            </returns>
    </member>
    <member name="T:System.Threading.AsyncLocalValueChangedArgs`1">
      <summary>
              向针对更改通知进行了注册的 <see cref="T:System.Threading.AsyncLocal`1" /> 实例提供数据更改信息的类。
            </summary>
      <typeparam name="T">
                数据的类型。
              </typeparam>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.CurrentValue">
      <summary>
              获取数据的当前值。
            </summary>
      <returns>
              数据的当前值。
            </returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.PreviousValue">
      <summary>
              获取数据的上一个值。
            </summary>
      <returns>
              数据的上一个值。
            </returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.ThreadContextChanged">
      <summary>
              返回一个值，该值指示是否由于执行上下文更改而更改了值。
            </summary>
      <returns>
              如果由于执行上下文更改而更改了值，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="T:System.Threading.AutoResetEvent">
      <summary>
              通知正在等待的线程已发生事件。
               无法继承此类。
            </summary>
    </member>
    <member name="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)">
      <summary>
              新实例初始化 <see cref="T:System.Threading.AutoResetEvent" /> 使用 Boolean 值，该值指示是否将初始状态设置为终止状态的类。
            </summary>
      <param name="initialState">
        <see langword="true" /> 若要将初始状态设置为终止状态; <see langword="false" /> 将初始状态设置为非终止。
              </param>
    </member>
    <member name="T:System.Threading.Barrier">
      <summary>
              使多个任务能够采用并行方式依据某种算法在多个阶段中协同工作。
            </summary>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32)">
      <summary>
              初始化 <see cref="T:System.Threading.Barrier" /> 类的新实例。
            </summary>
      <param name="participantCount">
                参与线程的数量。
              </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> 为小于 0 或大于 32767。
                </exception>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})">
      <summary>
              初始化 <see cref="T:System.Threading.Barrier" /> 类的新实例。
            </summary>
      <param name="participantCount">
                参与线程的数量。
              </param>
      <param name="postPhaseAction">
        <see cref="T:System.Action`1" /> 每个阶段完成之后执行。
                 可传递 null (在 Visual Basic 中为 Nothing)，以指示不执行任何操作。
              </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> 为小于 0 或大于 32767。
                </exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipant">
      <summary>
              通知 <see cref="T:System.Threading.Barrier" /> 就会有其他参与者。
            </summary>
      <returns>
              新的参与者将第一次参与的屏障阶段的数量。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  添加参与者将导致屏障的参与者计数超过 32767。
                
                  - 或 -
                
                  从阶段后操作中调用该方法。
                </exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipants(System.Int32)">
      <summary>
              通知 <see cref="T:System.Threading.Barrier" /> 就会有其他参与者。
            </summary>
      <param name="participantCount">
                若要添加到屏障的其他参与者的数。
              </param>
      <returns>
              新的参与者将第一次参与的屏障阶段的数量。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> 小于 0。
                
                  - 或 -
                
                  添加 <paramref name="participantCount" /> 参与者将导致屏障的参与者计数超过 32767。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  从阶段后操作中调用该方法。
                </exception>
    </member>
    <member name="P:System.Threading.Barrier.CurrentPhaseNumber">
      <summary>
              获取屏障数的当前阶段。
            </summary>
      <returns>
              返回的屏障数的当前阶段。
            </returns>
    </member>
    <member name="M:System.Threading.Barrier.Dispose">
      <summary>
              释放 <see cref="T:System.Threading.Barrier" /> 类的当前实例所使用的所有资源。
            </summary>
      <exception cref="T:System.InvalidOperationException">
                  从阶段后操作中调用该方法。
                </exception>
    </member>
    <member name="M:System.Threading.Barrier.Dispose(System.Boolean)">
      <summary>
              释放由 <see cref="T:System.Threading.Barrier" /> 占用的非托管资源，还可以另外再释放托管资源。
            </summary>
      <param name="disposing">
                为 true 则释放托管资源和非托管资源；为 false 则仅释放非托管资源。
              </param>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantCount">
      <summary>
              获取屏障中参与者的总数。
            </summary>
      <returns>
              返回屏障中参与者的总数。
            </returns>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantsRemaining">
      <summary>
              获取在当前阶段尚未发出信号屏障中的参与方的数量。
            </summary>
      <returns>
              返回在当前阶段尚未发出信号屏障中的参与方的数量。
            </returns>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipant">
      <summary>
              通知 <see cref="T:System.Threading.Barrier" /> 将会减少一个参与者。
            </summary>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  屏障已经有 0 个参与者。
                
                  - 或 -
                
                  从阶段后操作中调用该方法。
                </exception>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipants(System.Int32)">
      <summary>
              通知 <see cref="T:System.Threading.Barrier" /> 将会更少的参与者。
            </summary>
      <param name="participantCount">
                若要删除屏障的其他参与者的数。
              </param>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> 小于 0。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  屏障已经有 0 个参与者。
                
                  - 或 -
                
                  从阶段后操作中调用该方法。
                
                   - 或 -
                
                  当前的参与者计数小于指定 participantCount
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
                  参与者总数小于指定<paramref name=" participantCount" /></exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait">
      <summary>
              用信号通知的参与者已达到屏障和所有其他参与者到达屏障也会等待。
            </summary>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  从内部阶段后操作调用该方法、 当前屏障具有 0 个参与者，或屏障后将被终止的更多被注册为参与者线程。
                </exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException">
                  如果引发了异常从后阶段操作的屏障毕竟参与线程调用了 SignalAndWait，该异常将包装在 BarrierPostPhaseException 且在所有的参与线程上引发。
                </exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32)">
      <summary>
              用信号通知参与者已达到屏障，并等待所有其他参与者到达屏障，同时使用 32 位有符号的整数测量超时。
            </summary>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。
              </param>
      <returns>
              如果所有参与者都到达屏障后将被内指定的时间;否则为 false。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  从内部阶段后操作调用该方法、 当前屏障具有 0 个参与者，或屏障后将被终止的更多被注册为参与者线程。
                </exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException">
                  如果引发了异常从后阶段操作的屏障毕竟参与线程调用了 SignalAndWait，该异常将包装在 BarrierPostPhaseException 且在所有的参与线程上引发。
                </exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)">
      <summary>
              用信号通知参与者，已达到屏障，并等待所有其他参与者到达屏障，同时观察的取消标记。
            </summary>
      <param name="cancellationToken">
                要观察的 <see cref="T:System.Threading.CancellationToken" />。
              </param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  从内部阶段后操作调用该方法、 当前屏障具有 0 个参与者，或屏障后将被终止的更多被注册为参与者线程。
                </exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)">
      <summary>
              表示一个参与者已达到屏障，并等待所有其他参与者到达屏障，同时使用 <see cref="T:System.TimeSpan" /> 对象来测量时间间隔。
            </summary>
      <param name="timeout">
                表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。
              </param>
      <returns>
              如果所有其他参与者到达屏障后将被; 则为 true否则为 false。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" />为负数之外为-1 毫秒，表示无限期超时，或大于 32767。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  从内部阶段后操作调用该方法、 当前屏障具有 0 个参与者，或屏障后将被终止的更多被注册为参与者线程。
                </exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)">
      <summary>
              用信号通知参与者已达到屏障，并等待所有其他参与者到达屏障，同时使用 32 位带符号的整数测量超时，同时观察的取消标记。
            </summary>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。
              </param>
      <param name="cancellationToken">
                要观察的 <see cref="T:System.Threading.CancellationToken" />。
              </param>
      <returns>
              如果所有参与者都到达屏障后将被内指定的时间;否则为 false
            </returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  从内部阶段后操作调用该方法、 当前屏障具有 0 个参与者，或屏障后将被终止的更多被注册为参与者线程。
                </exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>
              表示一个参与者已达到屏障，并等待所有其他参与者到达屏障，同时使用 <see cref="T:System.TimeSpan" /> 测量时间间隔，同时观察的取消标记的对象。
            </summary>
      <param name="timeout">
                表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。
              </param>
      <param name="cancellationToken">
                要观察的 <see cref="T:System.Threading.CancellationToken" />。
              </param>
      <returns>
              如果所有其他参与者到达屏障后将被; 则为 true否则为 false。
            </returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" />为负数之外为-1 毫秒，表示无限期超时。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  从内部阶段后操作调用该方法、 当前屏障具有 0 个参与者，或屏障后将被终止的更多被注册为参与者线程。
                </exception>
    </member>
    <member name="T:System.Threading.BarrierPostPhaseException">
      <summary>
              时，将引发的异常的阶段后操作 <see cref="T:System.Threading.Barrier" /> 失败
            </summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor">
      <summary>
              使用由系统提供的用于描述错误的消息初始化 <see cref="T:System.Threading.BarrierPostPhaseException" /> 类的新实例。
            </summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)">
      <summary>
              新实例初始化 <see cref="T:System.Threading.BarrierPostPhaseException" /> 类，具有指定的内部异常。
            </summary>
      <param name="innerException">
                导致当前异常的异常。
              </param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String)">
      <summary>
              使用指定的描述错误的消息初始化 <see cref="T:System.Threading.BarrierPostPhaseException" /> 类的新实例。
            </summary>
      <param name="message">
                描述该异常的消息。
                 此构造函数的调用方需要确保此字符串已针对当前系统区域性进行了本地化。
              </param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              用序列化数据初始化 <see cref="T:System.Threading.BarrierPostPhaseException" /> 类的新实例。
            </summary>
      <param name="info">
                承载序列化对象数据的对象。
              </param>
      <param name="context">
                关于来源和目标的上下文信息
              </param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)">
      <summary>
              使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.Threading.BarrierPostPhaseException" /> 类的新实例。
            </summary>
      <param name="message">
                描述该异常的消息。
                 此构造函数的调用方需要确保此字符串已针对当前系统区域性进行了本地化。
              </param>
      <param name="innerException">
                导致当前异常的异常。
                 如果 <paramref name="innerException" /> 参数不为 <see langword="null" />，则当前异常将在处理内部异常的 <see langword="catch" /> 块中引发。
              </param>
    </member>
    <member name="T:System.Threading.ContextCallback">
      <summary>
              表示要在新的上下文中调用的方法。
            </summary>
      <param name="state">
                包含要使用的回调方法每次执行时其信息的对象。
              </param>
    </member>
    <member name="T:System.Threading.CountdownEvent">
      <summary>
              表示在计数变为零时处于有信号状态的同步基元。
            </summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.#ctor(System.Int32)">
      <summary>
              初始化的新实例 <see cref="T:System.Threading.CountdownEvent" /> 类，具有指定的计数。
            </summary>
      <param name="initialCount">
                最初所需设置信号的数量 <see cref="T:System.Threading.CountdownEvent" />。
              </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> 小于 0。
                </exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount">
      <summary>
              增量 <see cref="T:System.Threading.CountdownEvent" />的当前计数加 1。
            </summary>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  已设置的当前实例。
                
                  - 或 -
                
                  <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 等于或大于 <see cref="F:System.Int32.MaxValue" />。
                </exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount(System.Int32)">
      <summary>
              增量 <see cref="T:System.Threading.CountdownEvent" />的指定值的当前计数。
            </summary>
      <param name="signalCount">
                乘幂的值 <see cref="P:System.Threading.CountdownEvent.CurrentCount" />。
              </param>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> 小于或等于 0。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  已设置的当前实例。
                
                  - 或 -
                
                  <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 等于或大于 <see cref="F:System.Int32.MaxValue" /> 计数递增后 <paramref name="signalCount." /></exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.CurrentCount">
      <summary>
              获取所需设置事件的剩余信号数。
            </summary>
      <returns>
               若要设置的事件所需的剩余信号数。
            </returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose">
      <summary>
              释放 <see cref="T:System.Threading.CountdownEvent" /> 类的当前实例所使用的所有资源。
            </summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose(System.Boolean)">
      <summary>
              释放由 <see cref="T:System.Threading.CountdownEvent" /> 占用的非托管资源，还可以另外再释放托管资源。
            </summary>
      <param name="disposing">
                为 true 则释放托管资源和非托管资源；为 false 则仅释放非托管资源。
              </param>
    </member>
    <member name="P:System.Threading.CountdownEvent.InitialCount">
      <summary>
              获取最初所需设置事件信号的数目。
            </summary>
      <returns>
               最初必需设置事件的信号数。
            </returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.IsSet">
      <summary>
              表示 <see cref="T:System.Threading.CountdownEvent" /> 对象的当前计数是否已归零..
            </summary>
      <returns>
              如果当前的计数为零，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset">
      <summary>
              重置 <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 的值 <see cref="P:System.Threading.CountdownEvent.InitialCount" />。
            </summary>
      <exception cref="T:System.ObjectDisposedException">
                  已释放当前实例...
                </exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset(System.Int32)">
      <summary>
              重置 <see cref="P:System.Threading.CountdownEvent.InitialCount" /> 属性设置为指定的值。
            </summary>
      <param name="count">
                设置所需的信号的数量 <see cref="T:System.Threading.CountdownEvent" />。
              </param>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> 小于 0。
                </exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal(System.Int32)">
      <summary>
              注册与多个信号 <see cref="T:System.Threading.CountdownEvent" />, ，递减值的 <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 指定的量。
            </summary>
      <param name="signalCount">
                要注册的信号数。
              </param>
      <returns>
              设置如果信号导致计数归零，该事件则为 true;否则为 false。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> 小于 1。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  已设置的当前实例。
                   -或者 <paramref name="signalCount" /> 大于 <see cref="P:System.Threading.CountdownEvent.CurrentCount" />。
                </exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal">
      <summary>
              注册具有的信号 <see cref="T:System.Threading.CountdownEvent" />, ，递减值的 <see cref="P:System.Threading.CountdownEvent.CurrentCount" />。
            </summary>
      <returns>
              设置如果信号导致计数归零，该事件则为 true;否则为 false。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  已设置的当前实例。
                </exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount">
      <summary>
              尝试递增 <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 1。
            </summary>
      <returns>
              如果增量成功，则为 true否则为 false。
               如果 <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 已经是零，则此方法将返回 false。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 等于 <see cref="F:System.Int32.MaxValue" />。
                </exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount(System.Int32)">
      <summary>
              尝试递增 <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 指定值。
            </summary>
      <param name="signalCount">
                乘幂的值 <see cref="P:System.Threading.CountdownEvent.CurrentCount" />。
              </param>
      <returns>
              如果增量成功，则为 true否则为 false。
               如果 <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> 已经是的零，这将返回 false。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> 小于或等于 0。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  已设置的当前实例。
                
                  - 或 -
                
                  <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> + <paramref name="signalCount" /> 等于或大于 <see cref="F:System.Int32.MaxValue" />。
                </exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait">
      <summary>
              阻止当前线程，直到 <see cref="T:System.Threading.CountdownEvent" /> 设置。
            </summary>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32)">
      <summary>
              阻止当前线程，直到 <see cref="T:System.Threading.CountdownEvent" /> 使用 32 位有符号的整数测量超时的设置。
            </summary>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。
              </param>
      <returns>
              true <see cref="T:System.Threading.CountdownEvent" /> 已设置; 否则为 false。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。
                </exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Threading.CancellationToken)">
      <summary>
              阻止当前线程，直到 <see cref="T:System.Threading.CountdownEvent" /> 设置，同时观察 <see cref="T:System.Threading.CancellationToken" />。
            </summary>
      <param name="cancellationToken">
                要观察的 <see cref="T:System.Threading.CancellationToken" />。
              </param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                   -或- <see cref="T:System.Threading.CancellationTokenSource" /> 创建 <paramref name="cancellationToken" /> 被释放。
                </exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan)">
      <summary>
              阻止当前线程，直到 <see cref="T:System.Threading.CountdownEvent" /> 已设定，使用 <see cref="T:System.TimeSpan" /> 测量超时。
            </summary>
      <param name="timeout">
                表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。
              </param>
      <returns>
              true <see cref="T:System.Threading.CountdownEvent" /> 已设置; 否则为 false。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是-1 毫秒，表示无限期超时大于非负数字 <see cref="F:System.Int32.MaxValue" />。
                </exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>
              阻止当前线程，直到 <see cref="T:System.Threading.CountdownEvent" /> 已设定，使用 32 位有符号的整数测量超时，同时观察 <see cref="T:System.Threading.CancellationToken" />。
            </summary>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。
              </param>
      <param name="cancellationToken">
                要观察的 <see cref="T:System.Threading.CancellationToken" />。
              </param>
      <returns>
              true <see cref="T:System.Threading.CountdownEvent" /> 已设置; 否则为 false。
            </returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                   -或- <see cref="T:System.Threading.CancellationTokenSource" /> 创建 <paramref name="cancellationToken" /> 被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。
                </exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>
              阻止当前线程，直到 <see cref="T:System.Threading.CountdownEvent" /> 使用的设置 <see cref="T:System.TimeSpan" /> 测量超时，同时观察 <see cref="T:System.Threading.CancellationToken" />。
            </summary>
      <param name="timeout">
                表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。
              </param>
      <param name="cancellationToken">
                要观察的 <see cref="T:System.Threading.CancellationToken" />。
              </param>
      <returns>
              true <see cref="T:System.Threading.CountdownEvent" /> 已设置; 否则为 false。
            </returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                   -或- <see cref="T:System.Threading.CancellationTokenSource" /> 创建 <paramref name="cancellationToken" /> 被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是-1 毫秒，表示无限期超时大于非负数字 <see cref="F:System.Int32.MaxValue" />。
                </exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.WaitHandle">
      <summary>
              获取 <see cref="T:System.Threading.WaitHandle" /> 用来等待要设置的事件。
            </summary>
      <returns>
              一个 <see cref="T:System.Threading.WaitHandle" /> 用来等待要设置的事件。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
    </member>
    <member name="T:System.Threading.EventResetMode">
      <summary>
              指示是否 <see cref="T:System.Threading.EventWaitHandle" /> 之后重置自动或手动接收信号。
            </summary>
    </member>
    <member name="F:System.Threading.EventResetMode.AutoReset">
      <summary>
              当终止时， <see cref="T:System.Threading.EventWaitHandle" /> 释放一个线程后自动重置。
               如果没有线程在等待， <see cref="T:System.Threading.EventWaitHandle" /> 一直保持此线程将阻止，直到终止状态并在释放线程后将重置。
            </summary>
    </member>
    <member name="F:System.Threading.EventResetMode.ManualReset">
      <summary>
              当终止时， <see cref="T:System.Threading.EventWaitHandle" /> 释放所有等待的线程和手动重置之前一直保持终止状态。
            </summary>
    </member>
    <member name="T:System.Threading.EventWaitHandle">
      <summary>
              表示一个线程同步事件。
            </summary>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
      <summary>
              新实例初始化 <see cref="T:System.Threading.EventWaitHandle" /> 类中，指定是否在等待句柄最初发出信号，以及是否它将重置自动或手动。
            </summary>
      <param name="initialState">
        <see langword="true" /> 若要将初始状态设置为终止状态; <see langword="false" /> 以将其设置为终止状态。
              </param>
      <param name="mode">
                其中一个 <see cref="T:System.Threading.EventResetMode" /> 确定事件重置自动或手动的值。
              </param>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
      <summary>
              新实例初始化 <see cref="T:System.Threading.EventWaitHandle" /> 类，同时指定是否在等待句柄最初处于终止状态创建此调用后，是否自动或手动，则就会重置和系统同步事件的名称。
            </summary>
      <param name="initialState">
        <see langword="true" /> 若要将初始状态设置为终止状态如果进行此调用后; 创建命名的事件 <see langword="false" /> 以将其设置为终止状态。
              </param>
      <param name="mode">
                其中一个 <see cref="T:System.Threading.EventResetMode" /> 确定事件重置自动或手动的值。
              </param>
      <param name="name">
                系统级同步事件的名称。
              </param>
      <exception cref="T:System.IO.IOException">
                  出现 Win32 错误。
                </exception>
      <exception cref="T:System.UnauthorizedAccessException">
                  指定的事件存在并具有访问控制安全性，但用户不具有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />。
                </exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
                  无法创建指定的事件，可能是因为不同类型的等待句柄具有相同的名称。
                </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 超过 260 个字符。
                </exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
      <summary>
              初始化 <see cref="T:System.Threading.EventWaitHandle" /> 类的新实例，指定如果将等待句柄作为此调用的结果而创建，最初是否通过信号通知此句柄；指定是否自动或手动重置系统同步事件的名称，以及一个布尔变量，在调用后其值指示是否创建了命名的系统事件。
            </summary>
      <param name="initialState">
                如果将命名事件作为此调用的结果创建时将初始状态设置为通过信号通知，则为 <see langword="true" />；如果将其设置为不通过信号通知，则为 <see langword="false" />。
              </param>
      <param name="mode">
                其中一个 <see cref="T:System.Threading.EventResetMode" /> 值，它确定是自动还是手动重置事件。
              </param>
      <param name="name">
                系统范围的同步事件名称。
              </param>
      <param name="createdNew">
                此方法返回时，如果创建了本地事件（即，如果 <paramref name="name" /> 为 <see langword="null" /> 或空字符串）或创建了指定的命名系统事件，则包含 <see langword="true" />；如果指定的命名系统事件已存在，则为 <see langword="false" />。
                 此参数未经初始化即被传递。
              </param>
      <exception cref="T:System.IO.IOException">
                  出现 Win32 错误。
                </exception>
      <exception cref="T:System.UnauthorizedAccessException">
                  命名事件存在且具有访问控制安全性，但用户不具有 <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />。
                </exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
                  无法创建命名事件，可能是因为其他类型的等待句柄具有相同名称。
                </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 超过 260 个字符。
                </exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
      <summary>
              打开指定的命名的同步事件，如果它已存在。
            </summary>
      <param name="name">
                若要打开系统同步事件的名称。
              </param>
      <returns>
              一个对象，表示已命名的系统事件。
            </returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 是一个空字符串。
                
                  - 或 -
                
                  <paramref name="name" /> 超过 260 个字符。
                </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。
                </exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
                  已命名的系统事件不存在。
                </exception>
      <exception cref="T:System.IO.IOException">
                  出现 Win32 错误。
                </exception>
      <exception cref="T:System.UnauthorizedAccessException">
                  指定的事件存在，但用户没有使用它所需的安全访问权限。
                </exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Reset">
      <summary>
              将事件状态设置为非终止，从而导致线程受阻。
            </summary>
      <returns>
              如果该操作成功，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  之前已在此 <see cref="T:System.Threading.EventWaitHandle" /> 上调用 <see cref="M:System.Threading.WaitHandle.Close" /> 方法。
                </exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Set">
      <summary>
              将事件状态设置为有信号，从而允许一个或多个等待线程继续执行。
            </summary>
      <returns>
              如果该操作成功，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  之前已在此 <see cref="T:System.Threading.EventWaitHandle" /> 上调用 <see cref="M:System.Threading.WaitHandle.Close" /> 方法。
                </exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
      <summary>
              打开指定的命名同步事件（如果已经存在），返回指示操作是否成功的值。
            </summary>
      <param name="name">
                要打开的系统同步事件的名称。
              </param>
      <param name="result">
                当此方法返回时，如果调用成功，则包含表示命名同步事件的 <see cref="T:System.Threading.EventWaitHandle" /> 对象；如果调用失败，则为 <see langword="null" />。
                 该参数未经初始化即被处理。
              </param>
      <returns>
              如果成功打开命名同步事件，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 是一个空字符串。
                
                  - 或 -
                
                  <paramref name="name" /> 超过 260 个字符。
                </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。
                </exception>
      <exception cref="T:System.IO.IOException">
                  出现 Win32 错误。
                </exception>
      <exception cref="T:System.UnauthorizedAccessException">
                  命名事件存在，但用户不具有所需的安全访问权限。
                </exception>
    </member>
    <member name="T:System.Threading.ExecutionContext">
      <summary>
              管理当前线程的执行上下文。
               无法继承此类。
            </summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.Capture">
      <summary>
              捕获从当前线程的执行上下文。
            </summary>
      <returns>
        <see cref="T:System.Threading.ExecutionContext" /> 对象，表示当前线程的执行上下文。
            </returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.CreateCopy">
      <summary>
              创建当前执行上下文的副本。
            </summary>
      <returns>
        <see cref="T:System.Threading.ExecutionContext" /> 对象，表示当前执行上下文。
            </returns>
      <exception cref="T:System.InvalidOperationException">
                  无法复制此上下文，因为使用它。
                   可以复制唯一新捕获的上下文。
                </exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Dispose">
      <summary>
              释放 <see cref="T:System.Threading.ExecutionContext" /> 类的当前实例所使用的所有资源。
            </summary>
    </member>
    <member name="M:System.Threading.ExecutionContext.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              设置指定 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 重新创建当前执行上下文的实例所需的逻辑上下文信息的对象。
            </summary>
      <param name="info">
        <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 要使用的序列化信息填充的对象。
              </param>
      <param name="context">
        <see cref="T:System.Runtime.Serialization.StreamingContext" /> 结构，它表示序列化的目标上下文。
              </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="info" /> 为 <see langword="null" />。
                </exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.IsFlowSuppressed">
      <summary>
              指示是否当前正在取消执行上下文的流动。
            </summary>
      <returns>
        <see langword="true" /> 如果取消流动;否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="M:System.Threading.ExecutionContext.RestoreFlow">
      <summary>
              在异步线程间恢复执行上下文的流动。
            </summary>
      <exception cref="T:System.InvalidOperationException">
                  不能还原上下文流，因为未被取消。
                </exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)">
      <summary>
              在当前线程上指定的执行上下文中运行的方法。
            </summary>
      <param name="executionContext">
                要设置的 <see cref="T:System.Threading.ExecutionContext" />。
              </param>
      <param name="callback">
                一个 <see cref="T:System.Threading.ContextCallback" /> 委托，表示要在提供的执行上下文中运行的方法。
              </param>
      <param name="state">
                要传递给回调方法的对象。
              </param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="executionContext" /> 为 <see langword="null" />。
                
                  - 或 -
                
                  <paramref name="executionContext" /> 通过捕获操作不获取。
                
                  - 或 -
                
                  <paramref name="executionContext" /> 已使用作为参数传递给 <see cref="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)" /> 调用。
                </exception>
    </member>
    <member name="M:System.Threading.ExecutionContext.SuppressFlow">
      <summary>
              在异步线程间取消执行上下文的流动。
            </summary>
      <returns>
        <see cref="T:System.Threading.AsyncFlowControl" /> 用于恢复流动的结构。
            </returns>
      <exception cref="T:System.InvalidOperationException">
                  上下文流已取消。
                </exception>
    </member>
    <member name="T:System.Threading.HostExecutionContext">
      <summary>
              封装并传播在线程间的宿主执行上下文。
            </summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor">
      <summary>
              初始化 <see cref="T:System.Threading.HostExecutionContext" /> 类的新实例。
            </summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.#ctor(System.Object)">
      <summary>
              新实例初始化 <see cref="T:System.Threading.HostExecutionContext" /> 类使用指定的状态。
            </summary>
      <param name="state">
                表示宿主执行上下文状态的对象。
              </param>
    </member>
    <member name="M:System.Threading.HostExecutionContext.CreateCopy">
      <summary>
              创建当前宿主执行上下文的副本。
            </summary>
      <returns>
              一个 <see cref="T:System.Threading.HostExecutionContext" /> 对象，表示当前线程的主机上下文。
            </returns>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose">
      <summary>
              释放 <see cref="T:System.Threading.HostExecutionContext" /> 类的当前实例所使用的所有资源。
            </summary>
    </member>
    <member name="M:System.Threading.HostExecutionContext.Dispose(System.Boolean)">
      <summary>
              当在派生类中重写时，释放 <see cref="T:System.Threading.WaitHandle" /> 使用的非托管资源，并且可选择释放托管资源。
            </summary>
      <param name="disposing">
                若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。
              </param>
    </member>
    <member name="P:System.Threading.HostExecutionContext.State">
      <summary>
              获取或设置宿主执行上下文的状态。
            </summary>
      <returns>
              表示宿主执行上下文状态的对象。
            </returns>
    </member>
    <member name="T:System.Threading.HostExecutionContextManager">
      <summary>
              提供使公共语言运行时宿主可以参与流或迁移的执行上下文的功能。
            </summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.#ctor">
      <summary>
              初始化 <see cref="T:System.Threading.HostExecutionContextManager" /> 类的新实例。
            </summary>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Capture">
      <summary>
              捕获当前线程中的主机执行上下文。
            </summary>
      <returns>
              一个 <see cref="T:System.Threading.HostExecutionContext" /> 对象，表示当前线程的主机执行上下文。
            </returns>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.Revert(System.Object)">
      <summary>
              将宿主执行上下文恢复到它以前的状态。
            </summary>
      <param name="previousState">
                若要还原到以前上下文状态。
              </param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="previousState" /> 为 <see langword="null" />。
                
                  - 或 -
                
                  <paramref name="previousState" /> 未在当前线程上创建。
                
                  - 或 -
                
                  <paramref name="previousState" /> 不是最近一次状态 <see cref="T:System.Threading.HostExecutionContext" />。
                </exception>
    </member>
    <member name="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)">
      <summary>
              将当前宿主执行上下文设置为指定的主机执行上下文。
            </summary>
      <param name="hostExecutionContext">
                要设置的 <see cref="T:System.Threading.HostExecutionContext" />。
              </param>
      <returns>
              一个对象，用于还原 <see cref="T:System.Threading.HostExecutionContext" /> 为其原始状态。
            </returns>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="hostExecutionContext" /> 通过捕获操作不获取。
                
                  - 或 - 
                
                  <paramref name="hostExecutionContext" /> 已对上一个参数 <see cref="M:System.Threading.HostExecutionContextManager.SetHostExecutionContext(System.Threading.HostExecutionContext)" />  方法调用。
                </exception>
    </member>
    <member name="T:System.Threading.Interlocked">
      <summary>
              为多个线程共享的变量提供原子操作。
            </summary>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
      <summary>
              对两个 32 位整数进行求和并用和替换第一个整数，上述操作作为一个原子操作完成。
            </summary>
      <param name="location1">
                一个变量，包含要添加的第一个值。
                 两个值的总和存储在 <paramref name="location1" />。
              </param>
      <param name="value">
                要添加到整数的值 <paramref name="location1" />。
              </param>
      <returns>
              新值存储在 <paramref name="location1" />。
            </returns>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
      <summary>
              对两个 64 位整数进行求和并用和替换第一个整数，上述操作作为一个原子操作完成。
            </summary>
      <param name="location1">
                一个变量，包含要添加的第一个值。
                 两个值的总和存储在 <paramref name="location1" />。
              </param>
      <param name="value">
                要添加到整数的值 <paramref name="location1" />。
              </param>
      <returns>
              新值存储在 <paramref name="location1" />。
            </returns>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
      <summary>
              比较两个双精度浮点数是否相等，如果相等，则替换第一个值。
            </summary>
      <param name="location1">
                其值将与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。
              </param>
      <param name="value">
                比较结果相等时替换目标值的值。
              </param>
      <param name="comparand">
                与位于 <paramref name="location1" /> 处的值进行比较的值。
              </param>
      <returns>
        <paramref name="location1" /> 中的原始值。
            </returns>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
      <summary>
              比较两个 32 位有符号整数是否相等，如果相等，则替换第一个值。
            </summary>
      <param name="location1">
                其值将与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。
              </param>
      <param name="value">
                比较结果相等时替换目标值的值。
              </param>
      <param name="comparand">
                与位于 <paramref name="location1" /> 处的值进行比较的值。
              </param>
      <returns>
        <paramref name="location1" /> 中的原始值。
            </returns>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
      <summary>
              比较两个 64 位有符号整数是否相等，如果相等，则替换第一个值。
            </summary>
      <param name="location1">
                其值将与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。
              </param>
      <param name="value">
                比较结果相等时替换目标值的值。
              </param>
      <param name="comparand">
                与位于 <paramref name="location1" /> 处的值进行比较的值。
              </param>
      <returns>
        <paramref name="location1" /> 中的原始值。
            </returns>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
      <summary>
              比较两个平台特定的句柄或指针是否相等，如果相等，则替换第一个。
            </summary>
      <param name="location1">
                目标 <see cref="T:System.IntPtr" />, ，其值进行比较的值与 <paramref name="comparand" /> 并且可能被替换的 <paramref name="value" />。
              </param>
      <param name="value">
        <see cref="T:System.IntPtr" /> ，比较结果相等时替换目标值。
              </param>
      <param name="comparand">
        <see cref="T:System.IntPtr" /> 进行比较的位置处的值 <paramref name="location1" />。
              </param>
      <returns>
        <paramref name="location1" /> 中的原始值。
            </returns>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
      <summary>
              比较两个对象是否相等，如果相等，则替换第一个对象。
            </summary>
      <param name="location1">
                与进行比较的目标对象 <paramref name="comparand" /> 并且可能被替换。
              </param>
      <param name="value">
                比较结果相等时替换目标对象的对象。
              </param>
      <param name="comparand">
                与处的对象进行比较的对象 <paramref name="location1" />。
              </param>
      <returns>
        <paramref name="location1" /> 中的原始值。
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="location1" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
      <summary>
              比较两个单精度浮点数是否相等，如果相等，则替换第一个值。
            </summary>
      <param name="location1">
                其值将与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。
              </param>
      <param name="value">
                比较结果相等时替换目标值的值。
              </param>
      <param name="comparand">
                与位于 <paramref name="location1" /> 处的值进行比较的值。
              </param>
      <returns>
        <paramref name="location1" /> 中的原始值。
            </returns>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
      <summary>
              比较两个指定的引用类型的实例 <paramref name="T" /> 是否相等，如果相等，则替换第一个。
            </summary>
      <param name="location1">
                其值将与 <paramref name="comparand" /> 进行比较并且可能被替换的目标。
                 这是一个引用参数（C# 中为 <see langword="ref" />，Visual Basic 中为 <see langword="ByRef" />）。
              </param>
      <param name="value">
                比较结果相等时替换目标值的值。
              </param>
      <param name="comparand">
                与位于 <paramref name="location1" /> 处的值进行比较的值。
              </param>
      <typeparam name="T">
                要用于的类型 <paramref name="location1" />, ，<paramref name="value" />, ，和 <paramref name="comparand" />。
                 此类型必须是引用类型。
              </typeparam>
      <returns>
        <paramref name="location1" /> 中的原始值。
            </returns>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int32@)">
      <summary>
              以原子操作的形式递减指定变量的值并存储结果。
            </summary>
      <param name="location">
                其值要递减的变量。
              </param>
      <returns>
              递减的值。
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="location" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int64@)">
      <summary>
              以原子操作的形式递减指定变量的值并存储结果。
            </summary>
      <param name="location">
                其值要递减的变量。
              </param>
      <returns>
              递减的值。
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="location" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
      <summary>
              以原子操作的形式，将单精度浮点数设置为指定的值并返回原始值。
            </summary>
      <param name="location1">
                要设置为指定值的变量。
              </param>
      <param name="value">
        <paramref name="location1" /> 参数要设置成的值。
              </param>
      <returns>
        <paramref name="location1" /> 的原始值。
            </returns>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
      <summary>
              以原子操作的形式，将对象设置为指定的值并返回对原始对象的引用。
            </summary>
      <param name="location1">
                要设置为指定值的变量。
              </param>
      <param name="value">
        <paramref name="location1" /> 参数要设置成的值。
              </param>
      <returns>
        <paramref name="location1" /> 的原始值。
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="location1" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
      <summary>
              以原子操作的形式，将平台特定的句柄或指针设置为指定的值并返回原始值。
            </summary>
      <param name="location1">
                要设置为指定值的变量。
              </param>
      <param name="value">
        <paramref name="location1" /> 参数要设置成的值。
              </param>
      <returns>
        <paramref name="location1" /> 的原始值。
            </returns>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
      <summary>
              以原子操作的形式，将双精度浮点数设置为指定的值并返回原始值。
            </summary>
      <param name="location1">
                要设置为指定值的变量。
              </param>
      <param name="value">
        <paramref name="location1" /> 参数要设置成的值。
              </param>
      <returns>
        <paramref name="location1" /> 的原始值。
            </returns>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
      <summary>
              以原子操作的形式，将 32 位有符号整数设置为指定的值并返回原始值。
            </summary>
      <param name="location1">
                要设置为指定值的变量。
              </param>
      <param name="value">
        <paramref name="location1" /> 参数要设置成的值。
              </param>
      <returns>
        <paramref name="location1" /> 的原始值。
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="location1" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
      <summary>
              以原子操作的形式，将 64 位有符号整数设置为指定的值并返回原始值。
            </summary>
      <param name="location1">
                要设置为指定值的变量。
              </param>
      <param name="value">
        <paramref name="location1" /> 参数要设置成的值。
              </param>
      <returns>
        <paramref name="location1" /> 的原始值。
            </returns>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange``1(``0@,``0)">
      <summary>
              将指定类型 <paramref name="T" /> 的变量设置为指定值，并将原始值作为原子操作返回。
            </summary>
      <param name="location1">
                要设置为指定值的变量。
                 这是一个引用参数（C# 中为 <see langword="ref" />，Visual Basic 中为 <see langword="ByRef" />）。
              </param>
      <param name="value">
        <paramref name="location1" /> 参数要设置成的值。
              </param>
      <typeparam name="T">
                要用于 <paramref name="location1" /> 和 <paramref name="value" /> 的类型。
                 此类型必须是引用类型。
              </typeparam>
      <returns>
        <paramref name="location1" /> 的原始值。
            </returns>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location1" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int32@)">
      <summary>
              以原子操作的形式递增指定变量的值并存储结果。
            </summary>
      <param name="location">
                其值要递增的变量。
              </param>
      <returns>
              递增的值。
            </returns>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.Increment(System.Int64@)">
      <summary>
              以原子操作的形式递增指定变量的值并存储结果。
            </summary>
      <param name="location">
                其值要递增的变量。
              </param>
      <returns>
              递增的值。
            </returns>
      <exception cref="T:System.NullReferenceException">
        <paramref name="location" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrier">
      <summary>
              按以下方式同步内存访问︰ 执行当前线程的处理器不能重新排序说明对的调用之前的内存存取的方式 <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> 执行之后的内存存取，再执行到 <see cref="M:System.Threading.Interlocked.MemoryBarrier" />。
            </summary>
    </member>
    <member name="M:System.Threading.Interlocked.MemoryBarrierProcessWide">
    </member>
    <member name="M:System.Threading.Interlocked.Read(System.Int64@)">
      <summary>
              返回一个以原子操作形式加载的 64 位值。
            </summary>
      <param name="location">
                要加载的 64 位值。
              </param>
      <returns>
              加载的值。
            </returns>
    </member>
    <member name="T:System.Threading.LazyInitializer">
      <summary>
              提供延迟初始化例程。
            </summary>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)">
      <summary>
              初始化具有类型的默认构造函数的目标引用类型，如果其尚未已初始化。
            </summary>
      <param name="target">
                类型的引用 <paramref name="T" /> 初始化尚未初始化的情况。
              </param>
      <typeparam name="T">
                要初始化的引用的类型。
              </typeparam>
      <returns>
              类型的初始化的引用 <paramref name="T" />。
            </returns>
      <exception cref="T:System.MemberAccessException">
                  访问类型的构造函数的权限 <paramref name="T" /> 已丢失。
                </exception>
      <exception cref="T:System.MissingMemberException">
                  类型 <paramref name="T" /> 没有默认构造函数。
                </exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})">
      <summary>
              如果尚未已经初始化使用指定的函数初始化目标引用类型。
            </summary>
      <param name="target">
                类型的引用 <paramref name="T" /> 初始化如果其尚未已初始化。
              </param>
      <param name="valueFactory">
                调用以初始化该引用的函数。
              </param>
      <typeparam name="T">
                要初始化的引用的引用类型。
              </typeparam>
      <returns>
              类型的初始化的值 <paramref name="T" />。
            </returns>
      <exception cref="T:System.MissingMemberException">
                  类型 <paramref name="T" /> 没有默认构造函数。
                </exception>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="valueFactory" /> 返回了 null (在 Visual Basic 中为 Nothing)。
                </exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)">
      <summary>
              初始化具有其默认构造函数的目标引用或值类型，如果其尚未已初始化。
            </summary>
      <param name="target">
                一个引用或值类型的 <paramref name="T" /> 初始化如果其尚未已初始化。
              </param>
      <param name="initialized">
                对布尔值，该值确定目标是否已初始化的引用。
              </param>
      <param name="syncLock">
                对一个对象用作相互排斥锁初始化的引用 <paramref name="target" />。
                 如果 <paramref name="syncLock" /> 是 <see langword="null" />, ，将实例化一个新的对象。
              </param>
      <typeparam name="T">
                要初始化的引用的类型。
              </typeparam>
      <returns>
              类型的初始化的值 <paramref name="T" />。
            </returns>
      <exception cref="T:System.MemberAccessException">
                  访问类型的构造函数的权限 <paramref name="T" /> 已丢失。
                </exception>
      <exception cref="T:System.MissingMemberException">
                  类型 <paramref name="T" /> 没有默认构造函数。
                </exception>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})">
      <param name="target">
      </param>
      <param name="syncLock">
      </param>
      <param name="valueFactory">
      </param>
      <typeparam name="T">
      </typeparam>
      <returns>
      </returns>
    </member>
    <member name="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})">
      <summary>
              如果尚未已经初始化使用指定的函数初始化目标引用或值类型。
            </summary>
      <param name="target">
                一个引用或值类型的 <paramref name="T" /> 初始化如果其尚未已初始化。
              </param>
      <param name="initialized">
                对布尔值，该值确定目标是否已初始化的引用。
              </param>
      <param name="syncLock">
                对一个对象用作相互排斥锁初始化的引用 <paramref name="target" />。
                 如果 <paramref name="syncLock" /> 是 <see langword="null" />, ，将实例化一个新的对象。
              </param>
      <param name="valueFactory">
                调用以初始化引用或值的函数。
              </param>
      <typeparam name="T">
                要初始化的引用的类型。
              </typeparam>
      <returns>
              类型的初始化的值 <paramref name="T" />。
            </returns>
      <exception cref="T:System.MemberAccessException">
                  访问类型的构造函数的权限 <paramref name="T" /> 已丢失。
                </exception>
      <exception cref="T:System.MissingMemberException">
                  类型 <paramref name="T" /> 没有默认构造函数。
                </exception>
    </member>
    <member name="T:System.Threading.LockCookie">
      <summary>
              定义实现单个编写器/多个读取器语义的锁。
               这是值类型。
            </summary>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Object)">
      <summary>
              指示指定的对象是否为 <see cref="T:System.Threading.LockCookie" /> 和是否等于当前实例。
            </summary>
      <param name="obj">
                要与当前类型进行比较的对象。
              </param>
      <returns>
        <see langword="true" /> 如果值 <paramref name="obj" /> 等于当前实例的值; 否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="M:System.Threading.LockCookie.Equals(System.Threading.LockCookie)">
      <summary>
              该值指示当前实例是否等于指定 <see cref="T:System.Threading.LockCookie" />。
            </summary>
      <param name="obj">
        <see cref="T:System.Threading.LockCookie" /> 要与当前实例进行比较。
              </param>
      <returns>
        <see langword="true" /> 如果 <paramref name="obj" /> 等于当前实例的值; 否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="M:System.Threading.LockCookie.GetHashCode">
      <summary>
              返回此实例的哈希代码。
            </summary>
      <returns>
              32 位有符号整数哈希代码。
            </returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Equality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary>
              指示两个 <see cref="T:System.Threading.LockCookie" /> 结构是否相等。
            </summary>
      <param name="a">
        <see cref="T:System.Threading.LockCookie" /> 要与 <paramref name="b" />。
              </param>
      <param name="b">
        <see cref="T:System.Threading.LockCookie" /> 要与 <paramref name="a" />。
              </param>
      <returns>
              如果 <see langword="true" /> 等于 <paramref name="a" />，则为 <paramref name="b" />；否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="M:System.Threading.LockCookie.op_Inequality(System.Threading.LockCookie,System.Threading.LockCookie)">
      <summary>
              指示两个 <see cref="T:System.Threading.LockCookie" /> 结构是否不相等。
            </summary>
      <param name="a">
        <see cref="T:System.Threading.LockCookie" /> 要与 <paramref name="b" />。
              </param>
      <param name="b">
        <see cref="T:System.Threading.LockCookie" /> 要与 <paramref name="a" />。
              </param>
      <returns>
              如果 <see langword="true" /> 不等于 <paramref name="a" />，则为 <paramref name="b" />；否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="T:System.Threading.LockRecursionException">
      <summary>
              当进入锁定状态的递归与此锁定的递归策略不兼容时引发的异常。
            </summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor">
      <summary>
              使用由系统提供的用来描述错误的消息初始化 <see cref="T:System.Threading.LockRecursionException" /> 类的新实例。
            </summary>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String)">
      <summary>
              使用指定的描述错误的消息初始化 <see cref="T:System.Threading.LockRecursionException" /> 类的新实例。
            </summary>
      <param name="message">
                描述该异常的消息。
                 此构造函数的调用方必须确保此字符串已针对当前系统区域性进行了本地化。
              </param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              用序列化数据初始化 <see cref="T:System.Threading.LockRecursionException" /> 类的新实例。
            </summary>
      <param name="info">
                承载序列化对象数据的对象。
              </param>
      <param name="context">
                关于来源和目标的上下文信息
              </param>
    </member>
    <member name="M:System.Threading.LockRecursionException.#ctor(System.String,System.Exception)">
      <summary>
              使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.Threading.LockRecursionException" /> 类的新实例。
            </summary>
      <param name="message">
                描述该异常的消息。
                 此构造函数的调用方必须确保此字符串已针对当前系统区域性进行了本地化。
              </param>
      <param name="innerException">
                引发当前异常的异常。
                 如果 <paramref name="innerException" /> 参数不为 <see langword="null" />，则当前异常将在处理内部异常的 <see langword="catch" /> 块中引发。
              </param>
    </member>
    <member name="T:System.Threading.LockRecursionPolicy">
      <summary>
              指定同一个线程是否可以多次进入一个锁定状态。
            </summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.NoRecursion">
      <summary>
              如果线程尝试锁定以递归方式进入，则将引发异常。
               当此设置生效，一些类可能会允许特定的递归方式。
            </summary>
    </member>
    <member name="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
      <summary>
              一个线程可以输入锁以递归方式。
               一些类可能会限制这一功能。
            </summary>
    </member>
    <member name="T:System.Threading.ManualResetEvent">
      <summary>
              通知一个或多个正在等待的线程已发生事件。
               此类不能被继承。
            </summary>
    </member>
    <member name="M:System.Threading.ManualResetEvent.#ctor(System.Boolean)">
      <summary>
              新实例初始化 <see cref="T:System.Threading.ManualResetEvent" /> 使用 Boolean 值，该值指示是否将初始状态设置为终止状态的类。
            </summary>
      <param name="initialState">
        <see langword="true" /> 若要设置的初始状态信号; <see langword="false" /> 初始状态设置为终止状态。
              </param>
    </member>
    <member name="T:System.Threading.ManualResetEventSlim">
      <summary>
              提供的简化版本的 <see cref="T:System.Threading.ManualResetEvent" />。
            </summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor">
      <summary>
              新实例初始化 <see cref="T:System.Threading.ManualResetEventSlim" /> 类使用的非终止初始状态。
            </summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean)">
      <summary>
              新实例初始化 <see cref="T:System.Threading.ManualResetEventSlim" /> 使用 Boolean 值，该值指示是否将初始状态设置为终止状态的类。
            </summary>
      <param name="initialState">
                若要将初始状态设置为终止，则为 true；若要将初始状态设置为非终止，则为 false。
              </param>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.#ctor(System.Boolean,System.Int32)">
      <summary>
              新实例初始化 <see cref="T:System.Threading.ManualResetEventSlim" /> 类具有一个布尔值，该值指示是否将初始状态设置为终止和指定的旋转计数。
            </summary>
      <param name="initialState">
                若要将初始状态设置为终止，则为 true；若要将初始状态设置为非终止，则为 false。
              </param>
      <param name="spinCount">
                在回退到基于内核的等待操作之前发生的自旋等待数量。
              </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="spinCount" /> 为小于 0 或大于最大允许值。
                </exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose">
      <summary>
              释放 <see cref="T:System.Threading.ManualResetEventSlim" /> 类的当前实例所使用的所有资源。
            </summary>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Dispose(System.Boolean)">
      <summary>
              释放由 <see cref="T:System.Threading.ManualResetEventSlim" /> 占用的非托管资源，还可以另外再释放托管资源。
            </summary>
      <param name="disposing">
                为 true 则释放托管资源和非托管资源；为 false 则仅释放非托管资源。
              </param>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.IsSet">
      <summary>
              获取是否已设置事件。
            </summary>
      <returns>
              如果设置了事件，则为 true；否则为 false。
            </returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Reset">
      <summary>
              将事件状态设置为非终止，从而导致线程受阻。
            </summary>
      <exception cref="T:System.ObjectDisposedException">
                  对象已释放。
                </exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Set">
      <summary>
              将事件状态设置为有信号，从而允许一个或多个等待该事件的线程继续。
            </summary>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.SpinCount">
      <summary>
              获取在回退到基于内核的等待操作之前将发生的自旋等待数量。
            </summary>
      <returns>
              返回在回退到基于内核的等待操作之前将发生的自旋等待数量。
            </returns>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait">
      <summary>
              阻止当前线程，直到当前 <see cref="T:System.Threading.ManualResetEventSlim" /> 设置。
            </summary>
      <exception cref="T:System.InvalidOperationException">
                  已超过最大线程数。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  对象已释放。
                </exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32)">
      <summary>
              阻止当前线程，直到当前 <see cref="T:System.Threading.ManualResetEventSlim" /> 已设定，使用 32 位有符号的整数度量时间间隔。
            </summary>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。
              </param>
      <returns>
        <see langword="true" /> 如果 <see cref="T:System.Threading.ManualResetEventSlim" /> 设置; 否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  已超过最大线程数。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  对象已释放。
                </exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)">
      <summary>
              阻止当前线程，直到当前 <see cref="T:System.Threading.ManualResetEventSlim" /> 收到信号，同时观察 <see cref="T:System.Threading.CancellationToken" />。
            </summary>
      <param name="cancellationToken">
                要观察的 <see cref="T:System.Threading.CancellationToken" />。
              </param>
      <exception cref="T:System.InvalidOperationException">
                  已超过最大线程数。
                </exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  该对象已释放或 <see cref="T:System.Threading.CancellationTokenSource" /> 创建 <paramref name="cancellationToken" /> 已被释放。
                </exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
      <summary>
              阻止当前线程，直到当前 <see cref="T:System.Threading.ManualResetEventSlim" /> 已设定，使用 <see cref="T:System.TimeSpan" /> 度量时间间隔。
            </summary>
      <param name="timeout">
                表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。
              </param>
      <returns>
        <see langword="true" /> 如果 <see cref="T:System.Threading.ManualResetEventSlim" /> 设置; 否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。
                
                  - 或 -
                
                  内的毫秒数 <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  已超过最大线程数。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  对象已释放。
                </exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>
              阻止当前线程，直到当前 <see cref="T:System.Threading.ManualResetEventSlim" /> 已设定，使用 32 位有符号的整数测量时间间隔，同时观察 <see cref="T:System.Threading.CancellationToken" />。
            </summary>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。
              </param>
      <param name="cancellationToken">
                要观察的 <see cref="T:System.Threading.CancellationToken" />。
              </param>
      <returns>
        <see langword="true" /> 如果 <see cref="T:System.Threading.ManualResetEventSlim" /> 设置; 否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  已超过最大线程数。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  该对象已释放或 <see cref="T:System.Threading.CancellationTokenSource" /> 创建 <paramref name="cancellationToken" /> 已经被释放。
                </exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>
              阻止当前线程，直到当前 <see cref="T:System.Threading.ManualResetEventSlim" /> 已设定，使用 <see cref="T:System.TimeSpan" /> 测量时间间隔，同时观察 <see cref="T:System.Threading.CancellationToken" />。
            </summary>
      <param name="timeout">
                表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。
              </param>
      <param name="cancellationToken">
                要观察的 <see cref="T:System.Threading.CancellationToken" />。
              </param>
      <returns>
        <see langword="true" /> 如果 <see cref="T:System.Threading.ManualResetEventSlim" /> 设置; 否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。
                
                  - 或 -
                
                  内的毫秒数 <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。
                </exception>
      <exception cref="T:System.InvalidOperationException">
                  已超过最大线程数。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  该对象已释放或 <see cref="T:System.Threading.CancellationTokenSource" /> 创建 <paramref name="cancellationToken" /> 已被释放。
                </exception>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
      <summary>
              获取基础 <see cref="T:System.Threading.WaitHandle" /> 对象的 <see cref="T:System.Threading.ManualResetEventSlim" />。
            </summary>
      <returns>
              基础 <see cref="T:System.Threading.WaitHandle" /> 这事件对象 <see cref="T:System.Threading.ManualResetEventSlim" />。
            </returns>
    </member>
    <member name="T:System.Threading.Monitor">
      <summary>
              提供同步访问对象的机制。
            </summary>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object)">
      <summary>
              在指定对象上获取排他锁。
            </summary>
      <param name="obj">
                在其上获取监视器锁的对象。
              </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。
                </exception>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
      <summary>
              获取指定对象上的排他锁，并自动设置一个值，指示是否获取了该锁。
            </summary>
      <param name="obj">
                要在其上等待的对象。
              </param>
      <param name="lockTaken">
                尝试获取锁的结果，通过引用传递。
                 输入必须为 <see langword="false" />。
                 如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。
                 即使在尝试获取锁的过程中发生异常，也会设置输出。
              
                注意   如果没有发生异常，则此方法的输出始终为 <see langword="true" />。
              </param>
      <exception cref="T:System.ArgumentException">
        <paramref name="lockTaken" /> 的输入为 <see langword="true" />。
                </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。
                </exception>
    </member>
    <member name="M:System.Threading.Monitor.Exit(System.Object)">
      <summary>
              释放指定对象上的排他锁。
            </summary>
      <param name="obj">
                在其上释放锁的对象。
              </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。
                </exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
                  当前线程不拥有指定的对象的锁。
                </exception>
    </member>
    <member name="M:System.Threading.Monitor.IsEntered(System.Object)">
      <summary>
              确定当前线程是否保留指定对象上的锁。
            </summary>
      <param name="obj">
                要测试的对象。
              </param>
      <returns>
              如果当前线程持有 <paramref name="obj" /> 锁，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 为 <see langword="null" />。
                </exception>
    </member>
    <member name="M:System.Threading.Monitor.Pulse(System.Object)">
      <summary>
              通知等待队列中的线程锁定对象状态的更改。
            </summary>
      <param name="obj">
                线程正在等待的对象。
              </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。
                </exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
                  调用线程不拥有指定的对象的锁。
                </exception>
    </member>
    <member name="M:System.Threading.Monitor.PulseAll(System.Object)">
      <summary>
              通知所有的等待线程对象状态的更改。
            </summary>
      <param name="obj">
                发送脉冲的对象。
              </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。
                </exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
                  调用线程不拥有指定的对象的锁。
                </exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
      <summary>
              在指定的一段时间内尝试获取指定对象上的排他锁，并自动设置一个值，指示是否获得了该锁。
            </summary>
      <param name="obj">
                在其上获取锁的对象。
              </param>
      <param name="timeout">
                用于等待锁的时间。
                 值为 -1 毫秒表示指定无限期等待。
              </param>
      <param name="lockTaken">
                尝试获取锁的结果，通过引用传递。
                 输入必须为 <see langword="false" />。
                 如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。
                 即使在尝试获取锁的过程中发生异常，也会设置输出。
              </param>
      <exception cref="T:System.ArgumentException">
        <paramref name="lockTaken" /> 的输入为 <see langword="true" />。
                </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 的值（以毫秒计）为负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />（–1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。
                </exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
      <summary>
              在指定的毫秒数内尝试获取指定对象上的排他锁，并自动设置一个值，指示是否获取了该锁。
            </summary>
      <param name="obj">
                在其上获取锁的对象。
              </param>
      <param name="millisecondsTimeout">
                等待锁所需的毫秒数。
              </param>
      <param name="lockTaken">
                尝试获取锁的结果，通过引用传递。
                 输入必须为 <see langword="false" />。
                 如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。
                 即使在尝试获取锁的过程中发生异常，也会设置输出。
              </param>
      <exception cref="T:System.ArgumentException">
        <paramref name="lockTaken" /> 的输入为 <see langword="true" />。
                </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。
                </exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
      <summary>
              在指定的时间内尝试获取指定对象上的排他锁。
            </summary>
      <param name="obj">
                在其上获取锁的对象。
              </param>
      <param name="timeout">
        <see cref="T:System.TimeSpan" />，表示等待锁所需的时间量。
                 值为 -1 毫秒表示指定无限期等待。
              </param>
      <returns>
              如果当前线程获取该锁，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 的值（以毫秒计）为负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />（–1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。
                </exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
      <summary>
              在指定的毫秒数内尝试获取指定对象上的排他锁。
            </summary>
      <param name="obj">
                在其上获取锁的对象。
              </param>
      <param name="millisecondsTimeout">
                等待锁所需的毫秒数。
              </param>
      <returns>
              如果当前线程获取该锁，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是负数且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。
                </exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
      <summary>
              尝试获取指定对象上的排他锁，并自动设置一个值，指示是否获取了该锁。
            </summary>
      <param name="obj">
                在其上获取锁的对象。
              </param>
      <param name="lockTaken">
                尝试获取锁的结果，通过引用传递。
                 输入必须为 <see langword="false" />。
                 如果已获取锁，则输出为 <see langword="true" />；否则输出为 <see langword="false" />。
                 即使在尝试获取锁的过程中发生异常，也会设置输出。
              </param>
      <exception cref="T:System.ArgumentException">
        <paramref name="lockTaken" /> 的输入为 <see langword="true" />。
                </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。
                </exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object)">
      <summary>
              尝试获取指定对象的排他锁。
            </summary>
      <param name="obj">
                在其上获取锁的对象。
              </param>
      <returns>
              如果当前线程获取该锁，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。
                </exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object)">
      <summary>
              释放对象上的锁并阻止当前线程，直到它重新获取该锁。
            </summary>
      <param name="obj">
                要在其上等待的对象。
              </param>
      <returns>
              如果调用由于调用方重新获取了指定对象的锁而返回，则为 <see langword="true" />。
               如果未重新获取该锁，则此方法不会返回。
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。
                </exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
                  调用线程不拥有指定的对象的锁。
                </exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">
                  调用的线程 <see langword="Wait" /> 稍后从等待状态中断。
                   发生这种情况是当另一个线程调用此线程 <see cref="M:System.Threading.Thread.Interrupt" /> 方法。
                </exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
      <summary>
              释放对象上的锁并阻止当前线程，直到它重新获取该锁。
               如果已用指定的超时时间间隔，则线程进入就绪队列。
            </summary>
      <param name="obj">
                要在其上等待的对象。
              </param>
      <param name="millisecondsTimeout">
                线程进入就绪队列之前等待的毫秒数。
              </param>
      <returns>
              如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。
               此方法只有在重新获取该锁后才会返回。
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。
                </exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
                  调用线程不拥有指定的对象的锁。
                </exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">
                  调用的线程来<see langword="Wait" />稍后从等待状态中断。
                   另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
                  值<paramref name="millisecondsTimeout" />参数为负，且不等于<see cref="F:System.Threading.Timeout.Infinite" />。
                </exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
      <summary>
              释放对象上的锁并阻止当前线程，直到它重新获取该锁。
               如果已用指定的超时时间间隔，则线程进入就绪队列。
            </summary>
      <param name="obj">
                要在其上等待的对象。
              </param>
      <param name="timeout">
        <see cref="T:System.TimeSpan" />，表示线程进入就绪队列之前等待的时间量。
              </param>
      <returns>
              如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。
               此方法只有在重新获取该锁后才会返回。
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。
                </exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
                  调用线程不拥有指定的对象的锁。
                </exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">
                  调用的线程 <see langword="Wait" /> 稍后从等待状态中断。
                   发生这种情况是当另一个线程调用此线程 <see cref="M:System.Threading.Thread.Interrupt" /> 方法。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
                  值 <paramref name="timeout" /> 以毫秒为单位的参数为负数，并且不表示 <see cref="F:System.Threading.Timeout.Infinite" /> （-1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。
                </exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)">
      <summary>
              释放对象上的锁并阻止当前线程，直到它重新获取该锁。
               如果已用指定的超时时间间隔，则线程进入就绪队列。
               此方法还指定是否在等待之前退出上下文的同步域（如果在同步上下文中）然后重新获取该同步域。
            </summary>
      <param name="obj">
                要在其上等待的对象。
              </param>
      <param name="millisecondsTimeout">
                线程进入就绪队列之前等待的毫秒数。
              </param>
      <param name="exitContext">
                如果在等待前退出并重新获取上下文的同步域（如果在同步上下文中），则为 <see langword="true" />；否则为 <see langword="false" />。
              </param>
      <returns>
              如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。
               此方法只有在重新获取该锁后才会返回。
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。
                </exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see langword="Wait" /> 不从内调用同步的代码块。
                </exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">
                  调用的线程 <see langword="Wait" /> 稍后从等待状态中断。
                   发生这种情况是当另一个线程调用此线程 <see cref="M:System.Threading.Thread.Interrupt" /> 方法。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
                  值 <paramref name="millisecondsTimeout" /> 参数为负，且不等于 <see cref="F:System.Threading.Timeout.Infinite" />。
                </exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)">
      <summary>
              释放对象上的锁并阻止当前线程，直到它重新获取该锁。
               如果已用指定的超时时间间隔，则线程进入就绪队列。
               可以在等待之前退出同步上下文的同步域，随后重新获取该域。
            </summary>
      <param name="obj">
                要在其上等待的对象。
              </param>
      <param name="timeout">
        <see cref="T:System.TimeSpan" />，表示线程进入就绪队列之前等待的时间量。
              </param>
      <param name="exitContext">
                如果在等待前退出并重新获取上下文的同步域（如果在同步上下文中），则为 <see langword="true" />；否则为 <see langword="false" />。
              </param>
      <returns>
              如果在指定的时间过期之前重新获取该锁，则为 <see langword="true" />；如果在指定的时间过期之后重新获取该锁，则为 <see langword="false" />。
               此方法只有在重新获取该锁后才会返回。
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> 参数为 <see langword="null" />。
                </exception>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see langword="Wait" /> 不是从同步的代码块中调用的。
                </exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">
                  调用 Wait 的线程稍后会从等待状态中中断。
                   另一线程调用此线程的 <see cref="M:System.Threading.Thread.Interrupt" /> 方法时将发生这种情况。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 参数为负数，并且不表示 <see cref="F:System.Threading.Timeout.Infinite" />（-1 毫秒），或者大于 <see cref="F:System.Int32.MaxValue" />。
                </exception>
    </member>
    <member name="T:System.Threading.Mutex">
      <summary>
              还可用于进程间同步的同步基元。
            </summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor">
      <summary>
              使用默认属性初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。
            </summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean)">
      <summary>
              使用 Boolean 值（指示调用线程是否应具有互斥体的初始所有权）初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。
            </summary>
      <param name="initiallyOwned">
                如果给调用线程赋予互斥体的初始所属权，则为 <see langword="true" />；否则为 <see langword="false" />。
              </param>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
      <summary>
              使用 Boolean 值（指示调用线程是否应具有互斥体的初始所有权以及字符串是否为互斥体的名称）初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。
            </summary>
      <param name="initiallyOwned">
                如果为 <see langword="true" />，则给予调用线程已命名的系统互斥体的初始所属权（如果已命名的系统互斥体是通过此调用创建的）；否则为 <see langword="false" />。
              </param>
      <param name="name">
        <see cref="T:System.Threading.Mutex" /> 的名称。
                 如果值为 <see langword="null" />，则 <see cref="T:System.Threading.Mutex" /> 是未命名的。
              </param>
      <exception cref="T:System.UnauthorizedAccessException">
                  命名互斥体存在且具有访问控制安全性，但用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。
                </exception>
      <exception cref="T:System.IO.IOException">
                  出现 Win32 错误。
                </exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
                  无法创建命名互斥体，可能是由于其他类型的等待句柄具有相同名称。
                </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 超过 260 个字符。
                </exception>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
      <summary>
              使用可指示调用线程是否应具有互斥体的初始所有权以及字符串是否为互斥体的名称的 Boolean 值和当线程返回时可指示调用线程是否已赋予互斥体的初始所有权的 Boolean 值初始化 <see cref="T:System.Threading.Mutex" /> 类的新实例。
            </summary>
      <param name="initiallyOwned">
                如果为 <see langword="true" />，则给予调用线程已命名的系统互斥体的初始所属权（如果已命名的系统互斥体是通过此调用创建的）；否则为 <see langword="false" />。
              </param>
      <param name="name">
        <see cref="T:System.Threading.Mutex" /> 的名称。
                 如果值为 <see langword="null" />，则 <see cref="T:System.Threading.Mutex" /> 是未命名的。
              </param>
      <param name="createdNew">
                在此方法返回时，如果创建了局部互斥体（即，如果 <paramref name="name" /> 为 <see langword="null" /> 或空字符串）或指定的命名系统互斥体，则包含布尔值 <see langword="true" />；如果指定的命名系统互斥体已存在，则为 <see langword="false" />。
                 此参数未经初始化即被传递。
              </param>
      <exception cref="T:System.UnauthorizedAccessException">
                  命名互斥体存在且具有访问控制安全性，但用户不具备 <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />。
                </exception>
      <exception cref="T:System.IO.IOException">
                  出现 Win32 错误。
                </exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
                  无法创建命名互斥体，可能是由于其他类型的等待句柄具有相同名称。
                </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 超过 260 个字符。
                </exception>
    </member>
    <member name="M:System.Threading.Mutex.OpenExisting(System.String)">
      <summary>
              打开指定的已命名的互斥体（如果已经存在）。
            </summary>
      <param name="name">
                要打开的系统互斥体的名称。
              </param>
      <returns>
              表示已命名的系统互斥体的对象。
            </returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 是一个空字符串。
                
                  - 或 -
                
                  <paramref name="name" /> 超过 260 个字符。
                </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。
                </exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
                  已命名的互斥体不存在。
                </exception>
      <exception cref="T:System.IO.IOException">
                  出现 Win32 错误。
                </exception>
      <exception cref="T:System.UnauthorizedAccessException">
                  已命名的互斥体存在，但用户没有使用它所需的安全访问权限。
                </exception>
    </member>
    <member name="M:System.Threading.Mutex.ReleaseMutex">
      <summary>
              释放 <see cref="T:System.Threading.Mutex" /> 一次。
            </summary>
      <exception cref="T:System.ApplicationException">
                  调用线程不拥有互斥体。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  已释放当前实例。
                </exception>
    </member>
    <member name="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
      <summary>
              打开指定的已命名的互斥体（如果已经存在），并返回指示操作是否成功的值。
            </summary>
      <param name="name">
                要打开的系统互斥体的名称。
              </param>
      <param name="result">
                当此方法返回时，如果调用成功，则包含表示命名互斥体的 <see cref="T:System.Threading.Mutex" /> 对象；否则为 <see langword="null" />。
                 该参数未经初始化即被处理。
              </param>
      <returns>
              如果命名互斥体成功打开，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 是一个空字符串。
                
                  - 或 -
                
                  <paramref name="name" /> 超过 260 个字符。
                </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。
                </exception>
      <exception cref="T:System.IO.IOException">
                  出现 Win32 错误。
                </exception>
      <exception cref="T:System.UnauthorizedAccessException">
                  存在命名的互斥，但用户没有使用它时所需的安全访问权限。
                </exception>
    </member>
    <member name="T:System.Threading.ReaderWriterLock">
      <summary>
              定义支持单个写线程和多个读线程的锁。
            </summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.#ctor">
      <summary>
              初始化 <see cref="T:System.Threading.ReaderWriterLock" /> 类的新实例。
            </summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)">
      <summary>
              使用一个 <see cref="T:System.Int32" /> 超时值获取读线程锁。
            </summary>
      <param name="millisecondsTimeout">
                以毫秒为单位的超时。
              </param>
      <exception cref="T:System.ApplicationException">
        <paramref name="millisecondsTimeout" /> 授予的锁定请求之前到期。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)">
      <summary>
              使用一个 <see cref="T:System.TimeSpan" /> 超时值获取读线程锁。
            </summary>
      <param name="timeout">
                一个 <see langword="TimeSpan" />，用于指定超时时间。
              </param>
      <exception cref="T:System.ApplicationException">
        <paramref name="timeout" /> 授予的锁定请求之前到期。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 指定为-1 毫秒非负值。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)">
      <summary>
              使用一个 <see cref="T:System.Int32" /> 超时值获取写线程锁。
            </summary>
      <param name="millisecondsTimeout">
                以毫秒为单位的超时。
              </param>
      <exception cref="T:System.ApplicationException">
        <paramref name="timeout" /> 授予的锁定请求之前到期。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)">
      <summary>
              使用一个 <see cref="T:System.TimeSpan" /> 超时值获取写线程锁。
            </summary>
      <param name="timeout">
        <see langword="TimeSpan" />，用于指定超时时间。
              </param>
      <exception cref="T:System.ApplicationException">
        <paramref name="timeout" /> 授予的锁定请求之前到期。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 指定为-1 毫秒非负值。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)">
      <summary>
              指示获取序列号之后是否已将写线程锁授予某个线程。
            </summary>
      <param name="seqNum">
                序列号。
              </param>
      <returns>
              如果获取序列号之后已将写线程锁授予某一线程，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)">
      <summary>
              将线程的锁状态还原为调用 <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> 前的状态。
            </summary>
      <param name="lockCookie">
                一个 <see cref="T:System.Threading.LockCookie" />，由 <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> 返回。
              </param>
      <exception cref="T:System.ApplicationException">
                  线程不能将写线程锁。
                </exception>
      <exception cref="T:System.NullReferenceException">
        <paramref name="lockCookie" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.Finalize">
      <summary>
              确保垃圾回收器回收 <see cref="T:System.Threading.ReaderWriterLock" /> 对象时释放资源并执行其他清理操作。
            </summary>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsReaderLockHeld">
      <summary>
              获取一个值，该值指示当前线程是否持有读线程锁。
            </summary>
      <returns>
              如果当前线程持有读线程锁，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.IsWriterLockHeld">
      <summary>
              获取一个值，该值指示当前线程是否持有写线程锁。
            </summary>
      <returns>
              如果当前线程持有写线程锁，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseLock">
      <summary>
              释放锁，不管线程获取锁的次数如何。
            </summary>
      <returns>
              一个 <see cref="T:System.Threading.LockCookie" /> 值，表示释放的锁。
            </returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseReaderLock">
      <summary>
              减少锁计数。
            </summary>
      <exception cref="T:System.ApplicationException">
                  该线程不具有任何读取器或编写器锁。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.ReleaseWriterLock">
      <summary>
              减少写线程锁上的锁计数。
            </summary>
      <exception cref="T:System.ApplicationException">
                  线程不能将写线程锁。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)">
      <summary>
              将线程的锁状态还原为调用 <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" /> 前的状态。
            </summary>
      <param name="lockCookie">
                一个 <see cref="T:System.Threading.LockCookie" />，由 <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" /> 返回。
              </param>
      <exception cref="T:System.NullReferenceException">
        <paramref name="lockCookie" /> 的地址为空指针。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)">
      <summary>
              使用一个 <see langword="Int32" /> 超时值将读线程锁升级为写线程锁。
            </summary>
      <param name="millisecondsTimeout">
                以毫秒为单位的超时。
              </param>
      <returns>
              一个 <see cref="T:System.Threading.LockCookie" /> 值。
            </returns>
      <exception cref="T:System.ApplicationException">
        <paramref name="millisecondsTimeout" /> 授予的锁定请求之前到期。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)">
      <summary>
              使用一个 <see langword="TimeSpan" /> 超时值将读线程锁升级为写线程锁。
            </summary>
      <param name="timeout">
        <see langword="TimeSpan" />，用于指定超时时间。
              </param>
      <returns>
              一个 <see cref="T:System.Threading.LockCookie" /> 值。
            </returns>
      <exception cref="T:System.ApplicationException">
        <paramref name="timeout" /> 授予的锁定请求之前到期。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 指定为-1 毫秒非负值。
                </exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLock.WriterSeqNum">
      <summary>
              获取当前序列号。
            </summary>
      <returns>
              当前序列号。
            </returns>
    </member>
    <member name="T:System.Threading.ReaderWriterLockSlim">
      <summary>
              表示用于管理资源访问的锁定状态，可实现多线程读取或进行独占式写入访问。
            </summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor">
      <summary>
              使用默认属性值初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的新实例。
            </summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
      <summary>
              在指定锁定递归策略的情况下初始化 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的新实例。
            </summary>
      <param name="recursionPolicy">
                枚举值之一，用于指定锁定递归策略。
              </param>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
      <summary>
              获取已进入读取模式锁定状态的独有线程的总数。
            </summary>
      <returns>
              已进入读取模式锁定状态的独有线程的数量。
            </returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.Dispose">
      <summary>
              释放 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 类的当前实例所使用的所有资源。
            </summary>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> 大于零。
                
                  - 或 -
                
                  <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> 大于零。
                
                  - 或 -
                
                  <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> 大于零。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
      <summary>
              尝试进入读取模式锁定状态。
            </summary>
      <exception cref="T:System.Threading.LockRecursionException">
                  当前线程持有读取锁时将无法获取写入锁。
                
                  - 或 -
                
                  <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，并且当前线程在已持有读取锁时已尝试获取读取锁。
                
                  - 或 -
                
                  <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性为 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />，并且当前线程在已持有写入锁时已尝试获取读取锁。
                
                  - 或 -
                
                  递归数将超出该计数器的容量。
                   此限值很大，因此应用程序永远不会遇到此异常。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
      <summary>
              尝试进入可升级模式锁定状态。
            </summary>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性是 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> 并且当前线程已在任何模式下进入了该锁。
                
                  - 或 -
                
                  当前线程已进入读取的模式，因此尝试进入可升级模式将有死锁的可能性。
                
                  - 或 -
                
                  递归数将超出该计数器的容量。
                   限制为应用程序应永远不会遇到它太大。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已被释放。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
      <summary>
              尝试进入写入模式锁定状态。
            </summary>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性是 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> 并且当前线程已在任何模式下进入了该锁。
                
                  - 或 -
                
                  当前线程已进入读取的模式，因此尝试进入写入模式锁定将有死锁的可能性。
                
                  - 或 -
                
                  递归数将超出该计数器的容量。
                   限制为应用程序应永远不会遇到它太大。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已被释放。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
      <summary>
              减少读取模式的递归计数，并在生成的计数为 0（零）时退出读取模式。
            </summary>
      <exception cref="T:System.Threading.SynchronizationLockException">
                  当前线程没有已进入读取模式的锁定。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
      <summary>
              减少可升级模式的递归计数，并在生成的计数为 0（零）时退出可升级模式。
            </summary>
      <exception cref="T:System.Threading.SynchronizationLockException">
                  当前线程没有已进入可升级模式的锁定。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
      <summary>
              减少写入模式的递归计数，并在生成的计数为 0（零）时退出写入模式。
            </summary>
      <exception cref="T:System.Threading.SynchronizationLockException">
                  当前线程没有已进入写入模式的锁定。
                </exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
      <summary>
              获取一个值，该值指示当前线程是否已进入读取模式的锁定状态。
            </summary>
      <returns>
              如果当前线程已进入读取模式，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
      <summary>
              获取一个值，该值指示当前线程是否已进入可升级模式的锁定状态。
            </summary>
      <returns>
              如果当前线程已进入可升级模式，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
      <summary>
              获取一个值，该值指示当前线程是否已进入写入模式的锁定状态。
            </summary>
      <returns>
              如果当前线程已进入写入模式，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
      <summary>
              获取一个值，该值指示当前 <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象的递归策略。
            </summary>
      <returns>
              枚举值之一，用于指定锁定递归策略。
            </returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
      <summary>
              获取当前线程进入读取模式锁定状态的次数，用于指示递归。
            </summary>
      <returns>
              如果当前线程未进入读取模式，则为 0（零）；如果线程已进入读取模式但却不是以递归方式进入的，则为 1；或者如果线程已经以递归方式进入锁定模式 n - 1 次，则为 n。
            </returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
      <summary>
              获取当前线程进入可升级模式锁定状态的次数，用于指示递归。
            </summary>
      <returns>
              如果当前线程没有进入可升级模式，则为 0；如果线程已进入可升级模式却不是以递归方式进入的，则为 1；或者如果线程已经以递归方式进入可升级模式 n - 1 次，则为 n。
            </returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
      <summary>
              获取当前线程进入写入模式锁定状态的次数，用于指示递归。
            </summary>
      <returns>
              如果当前线程没有进入写入模式，则为 0；如果线程已进入写入模式却不是以递归方式进入的，则为 1；或者如果线程已经以递归方式进入写入模式 n - 1 次，则为 n。
            </returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
      <summary>
              尝试进入读取模式锁定状态，可以选择整数超时时间。
            </summary>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)，表示无限期等待。
              </param>
      <returns>
              如果调用线程已进入读取模式，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性是 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> 和当前线程已进入该锁。
                
                  - 或 -
                
                  递归数将超出该计数器的容量。
                   限制为应用程序应永远不会遇到它太大。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
                  值 <paramref name="millisecondsTimeout" /> 为负，但不等于 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，这是唯一允许的值为负。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
      <summary>
              尝试进入读取模式锁定状态，可以选择超时时间。
            </summary>
      <param name="timeout">
                等待的间隔；或为 -1 毫秒，表示无限期等待。
              </param>
      <returns>
              如果调用线程已进入读取模式，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性是 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> 和当前线程已进入该锁。
                
                  - 或 -
                
                  递归数将超出该计数器的容量。
                   限制为应用程序应永远不会遇到它太大。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
                  值 <paramref name="timeout" /> 为负，但不等于-1 毫秒，这是唯一允许的值为负。
                
                  - 或 -
                
                  值 <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" /> 毫秒为单位。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
      <summary>
              尝试进入可升级模式锁定状态，可以选择超时时间。
            </summary>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)，表示无限期等待。
              </param>
      <returns>
              如果调用线程已进入可升级模式，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性是 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> 和当前线程已进入该锁。
                
                  - 或 -
                
                  当前线程的锁最初进入读取模式，并因此尝试进入可升级模式会创建导致死锁的可能性。
                
                  - 或 -
                
                  递归数将超出该计数器的容量。
                   限制为应用程序应永远不会遇到它太大。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
                  值 <paramref name="millisecondsTimeout" /> 为负，但不等于 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，这是唯一允许的值为负。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
      <summary>
              尝试进入可升级模式锁定状态，可以选择超时时间。
            </summary>
      <param name="timeout">
                等待的间隔；或为 -1 毫秒，表示无限期等待。
              </param>
      <returns>
              如果调用线程已进入可升级模式，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性是 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> 和当前线程已进入该锁。
                
                  - 或 -
                
                  当前线程的锁最初进入读取模式，并因此尝试进入可升级模式会创建导致死锁的可能性。
                
                  - 或 -
                
                  递归数将超出该计数器的容量。
                   限制为应用程序应永远不会遇到它太大。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
                  值 <paramref name="timeout" /> 为负，但不等于-1 毫秒，这是唯一允许的值为负。
                
                  - 或 -
                
                  值 <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" /> 毫秒为单位。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
      <summary>
              尝试进入写入模式锁定状态，可以选择超时时间。
            </summary>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 -1 (<see cref="F:System.Threading.Timeout.Infinite" />)，表示无限期等待。
              </param>
      <returns>
              如果调用线程已进入写入模式，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性是 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> 和当前线程已进入该锁。
                
                  - 或 -
                
                  当前线程的锁最初进入读取模式，并因此尝试进入写入模式会创建导致死锁的可能性。
                
                  - 或 -
                
                  递归数将超出该计数器的容量。
                   限制为应用程序应永远不会遇到它太大。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
                  值 <paramref name="millisecondsTimeout" /> 为负，但不等于 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，这是唯一允许的值为负。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。
                </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
      <summary>
              尝试进入写入模式锁定状态，可以选择超时时间。
            </summary>
      <param name="timeout">
                等待的间隔；或为 -1 毫秒，表示无限期等待。
              </param>
      <returns>
              如果调用线程已进入写入模式，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.Threading.LockRecursionException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> 属性是 <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> 和当前线程已进入该锁。
                
                  - 或 -
                
                  当前线程的锁最初进入读取模式，并因此尝试进入写入模式会创建导致死锁的可能性。
                
                  - 或 -
                
                  递归数将超出该计数器的容量。
                   限制为应用程序应永远不会遇到它太大。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
                  值 <paramref name="timeout" /> 为负，但不等于-1 毫秒，这是唯一允许的值为负。
                
                  - 或 -
                
                  值 <paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" /> 毫秒为单位。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.ReaderWriterLockSlim" /> 对象已释放。
                </exception>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
      <summary>
              获取等待进入读取模式锁定状态的线程总数。
            </summary>
      <returns>
              等待进入读取模式的线程总数。
            </returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
      <summary>
              获取等待进入可升级模式锁定状态的线程总数。
            </summary>
      <returns>
              等待进入可升级模式的线程总数。
            </returns>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
      <summary>
              获取等待进入写入模式锁定状态的线程总数。
            </summary>
      <returns>
              等待进入写入模式的线程总数。
            </returns>
    </member>
    <member name="T:System.Threading.Semaphore">
      <summary>
              限制可同时访问某一资源或资源池的线程数。
            </summary>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)">
      <summary>
              初始化 <see cref="T:System.Threading.Semaphore" /> 类的新实例，并指定初始入口数和最大并发入口数。
            </summary>
      <param name="initialCount">
                可以同时授予的信号量的初始请求数。
              </param>
      <param name="maximumCount">
                可以同时授予的信号量的最大请求数。
              </param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCount" /> 大于 <paramref name="maximumCount" />。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maximumCount" /> 小于 1。
                
                  - 或 -
                
                  <paramref name="initialCount" /> 小于 0。
                </exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)">
      <summary>
              初始化 <see cref="T:System.Threading.Semaphore" /> 类的新实例，并指定初始入口数和最大并发入口数，可以选择指定系统信号量对象的名称。
            </summary>
      <param name="initialCount">
                可以同时授予的信号量的初始请求数。
              </param>
      <param name="maximumCount">
                可以同时授予的信号量的最大请求数。
              </param>
      <param name="name">
                命名系统信号量对象的名称。
              </param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCount" /> 大于 <paramref name="maximumCount" />。
                
                  - 或 -
                
                  <paramref name="name" /> 超过 260 个字符。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maximumCount" /> 为小于 1。
                
                  - 或 -
                
                  <paramref name="initialCount" /> 小于 0。
                </exception>
      <exception cref="T:System.IO.IOException">
                  出现 Win32 错误。
                </exception>
      <exception cref="T:System.UnauthorizedAccessException">
                  名称为信号量存在并具有访问控制安全性，但用户不具有 <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />。
                </exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
                  不能创建名称为信号量，可能是因为不同类型的等待句柄具有相同的名称。
                </exception>
    </member>
    <member name="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
      <summary>
              初始化 <see cref="T:System.Threading.Semaphore" /> 类的新实例，并指定初始入口数和最大并发入口数，还可以选择指定系统信号量对象的名称，以及指定一个变量来接收指示是否创建了新系统信号量的值。
            </summary>
      <param name="initialCount">
                可以同时满足的信号量的初始请求数。
              </param>
      <param name="maximumCount">
                可以同时满足的信号量的最大请求数。
              </param>
      <param name="name">
                命名系统信号量对象的名称。
              </param>
      <param name="createdNew">
                在此方法返回时，如果创建了本地信号量（即，如果 <paramref name="name" /> 为 <see langword="null" /> 或空字符串）或指定的命名系统信号量，则包含 <see langword="true" />；如果指定的命名系统信号量已存在，则为 <see langword="false" />。
                 此参数未经初始化即被传递。
              </param>
      <exception cref="T:System.ArgumentException">
        <paramref name="initialCount" /> 大于 <paramref name="maximumCount" />。
                
                  - 或 -
                
                  <paramref name="name" /> 超过 260 个字符。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="maximumCount" /> 小于 1。
                
                  - 或 -
                
                  <paramref name="initialCount" /> 小于 0。
                </exception>
      <exception cref="T:System.IO.IOException">
                  出现 Win32 错误。
                </exception>
      <exception cref="T:System.UnauthorizedAccessException">
                  命名信号量存在且具有访问控制安全性，用户不具有 <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />。
                </exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
                  无法创建命名信号量，可能是由于其他类型的等待句柄具有相同名称。
                </exception>
    </member>
    <member name="M:System.Threading.Semaphore.OpenExisting(System.String)">
      <summary>
              打开指定名称为信号量（如果已经存在）。
            </summary>
      <param name="name">
                要打开的系统信号量的名称。
              </param>
      <returns>
              一个对象，表示已命名的系统信号量。
            </returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 是一个空字符串。
                
                  - 或 -
                
                  <paramref name="name" /> 超过 260 个字符。
                </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。
                </exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">
                  不存在名称为信号量。
                </exception>
      <exception cref="T:System.IO.IOException">
                  出现 Win32 错误。
                </exception>
      <exception cref="T:System.UnauthorizedAccessException">
                  存在名称为信号量，但用户没有使用它所需的安全访问权限。
                </exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release">
      <summary>
              退出信号量并返回前一个计数。
            </summary>
      <returns>
              调用 <see cref="Overload:System.Threading.Semaphore.Release" /> 方法前信号量的计数。
            </returns>
      <exception cref="T:System.Threading.SemaphoreFullException">
                  信号量计数已是最大值。
                </exception>
      <exception cref="T:System.IO.IOException">
                  名称为信号量出现 Win32 错误。
                </exception>
      <exception cref="T:System.UnauthorizedAccessException">
                  当前的信号量表示已命名的系统信号量，但用户不具有 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />。
                
                  - 或 -
                
                  当前的信号量表示已命名的系统信号量，但它不以打开 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />。
                </exception>
    </member>
    <member name="M:System.Threading.Semaphore.Release(System.Int32)">
      <summary>
              以指定的次数退出信号量并返回前一个计数。
            </summary>
      <param name="releaseCount">
                退出信号量的次数。
              </param>
      <returns>
              调用 <see cref="Overload:System.Threading.Semaphore.Release" /> 方法前信号量的计数。
            </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="releaseCount" /> 小于 1。
                </exception>
      <exception cref="T:System.Threading.SemaphoreFullException">
                  信号量计数已是最大值。
                </exception>
      <exception cref="T:System.IO.IOException">
                  名称为信号量出现 Win32 错误。
                </exception>
      <exception cref="T:System.UnauthorizedAccessException">
                  当前的信号量表示已命名的系统信号量，但用户不具有 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> 权限。
                
                  - 或 -
                
                  当前的信号量表示已命名的系统信号量，但它不以打开 <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> 权限。
                </exception>
    </member>
    <member name="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)">
      <summary>
              打开指定名称为信号量（如果已经存在），并返回指示操作是否成功的值。
            </summary>
      <param name="name">
                要打开的系统信号量的名称。
              </param>
      <param name="result">
                当此方法返回时，如果调用成功，则包含表示命名信号的 <see cref="T:System.Threading.Semaphore" /> 对象；否则为 <see langword="null" />。
                 该参数未经初始化即被处理。
              </param>
      <returns>
              如果命名信号量成功打开，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> 是一个空字符串。
                
                  - 或 -
                
                  <paramref name="name" /> 超过 260 个字符。
                </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> 为 <see langword="null" />。
                </exception>
      <exception cref="T:System.IO.IOException">
                  出现 Win32 错误。
                </exception>
      <exception cref="T:System.UnauthorizedAccessException">
                  存在该命名信号量，但用户没有使用它时所需的安全访问权限。
                </exception>
    </member>
    <member name="T:System.Threading.SemaphoreFullException">
      <summary>
              对已经达到最大计数值的信号量调用 <see cref="Overload:System.Threading.Semaphore.Release" /> 方法时引发的异常。
            </summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor">
      <summary>
              使用默认值初始化 <see cref="T:System.Threading.SemaphoreFullException" /> 类的新实例。
            </summary>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String)">
      <summary>
              用指定的错误消息初始化 <see cref="T:System.Threading.SemaphoreFullException" /> 类的新实例。
            </summary>
      <param name="message">
                解释异常原因的错误消息。
              </param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              用序列化数据初始化 <see cref="T:System.Threading.SemaphoreFullException" /> 类的新实例。
            </summary>
      <param name="info">
                存放有关所引发异常的序列化对象数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象。
              </param>
      <param name="context">
        <see cref="T:System.Runtime.Serialization.StreamingContext" /> 对象，它包含有关源或目标的上下文信息。
              </param>
    </member>
    <member name="M:System.Threading.SemaphoreFullException.#ctor(System.String,System.Exception)">
      <summary>
              使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.Threading.SemaphoreFullException" /> 类的新实例。
            </summary>
      <param name="message">
                解释异常原因的错误消息。
              </param>
      <param name="innerException">
                导致当前异常的异常。
                 如果 <paramref name="innerException" /> 参数不为 <see langword="null" />，则当前异常将在处理内部异常的 <see langword="catch" /> 块中引发。
              </param>
    </member>
    <member name="T:System.Threading.SemaphoreSlim">
      <summary>
              对可同时访问资源或资源池的线程数加以限制的 <see cref="T:System.Threading.Semaphore" /> 的轻量替代。
            </summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32)">
      <summary>
              初始化 <see cref="T:System.Threading.SemaphoreSlim" /> 类的新实例，以指定可同时授予的请求的初始数量。
            </summary>
      <param name="initialCount">
                可以同时授予的信号量的初始请求数。
              </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> 小于 0。
                </exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)">
      <summary>
              初始化 <see cref="T:System.Threading.SemaphoreSlim" /> 类的新实例，同时指定可同时授予的请求的初始数量和最大数量。
            </summary>
      <param name="initialCount">
                可以同时授予的信号量的初始请求数。
              </param>
      <param name="maxCount">
                可以同时授予的信号量的最大请求数。
              </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> 小于 0，或 <paramref name="initialCount" /> 大于 <paramref name="maxCount" />, ，或 <paramref name="maxCount" /> 等于或小于 0。
                </exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.AvailableWaitHandle">
      <summary>
              返回一个可用于在信号量上等待的 <see cref="T:System.Threading.WaitHandle" />。
            </summary>
      <returns>
              可用于在信号量上等待的 <see cref="T:System.Threading.WaitHandle" />。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  已释放了 <see cref="T:System.Threading.SemaphoreSlim" />。
                </exception>
    </member>
    <member name="P:System.Threading.SemaphoreSlim.CurrentCount">
      <summary>
              获取可以输入 <see cref="T:System.Threading.SemaphoreSlim" /> 对象的剩余线程数。
            </summary>
      <returns>
              可以输入信号量的剩余线程数。
            </returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose">
      <summary>
              释放 <see cref="T:System.Threading.SemaphoreSlim" /> 类的当前实例所使用的所有资源。
            </summary>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)">
      <summary>
              释放由 <see cref="T:System.Threading.SemaphoreSlim" /> 占用的非托管资源，还可以另外再释放托管资源。
            </summary>
      <param name="disposing">
                若要释放托管资源和非托管资源，则为 <see langword="true" />；若仅释放非托管资源，则为 <see langword="false" />。
              </param>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release">
      <summary>
              释放 <see cref="T:System.Threading.SemaphoreSlim" /> 对象一次。
            </summary>
      <returns>
        <see cref="T:System.Threading.SemaphoreSlim" /> 的前一个计数。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.Threading.SemaphoreFullException">
        <see cref="T:System.Threading.SemaphoreSlim" /> 已达到其最大大小。
                </exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Release(System.Int32)">
      <summary>
              释放 <see cref="T:System.Threading.SemaphoreSlim" /> 对象指定的次数。
            </summary>
      <param name="releaseCount">
                退出信号量的次数。
              </param>
      <returns>
        <see cref="T:System.Threading.SemaphoreSlim" /> 的前一个计数。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="releaseCount" /> 小于 1。
                </exception>
      <exception cref="T:System.Threading.SemaphoreFullException">
        <see cref="T:System.Threading.SemaphoreSlim" /> 已达到其最大大小。
                </exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>
              阻止当前线程，直至它可进入 <see cref="T:System.Threading.SemaphoreSlim" /> 为止，并使用 <see cref="T:System.TimeSpan" /> 来指定超时，同时观察 <see cref="T:System.Threading.CancellationToken" />。
            </summary>
      <param name="timeout">
                表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。
              </param>
      <param name="cancellationToken">
                要观察的 <see cref="T:System.Threading.CancellationToken" />。
              </param>
      <returns>
              如果当前线程成功进入 <see cref="T:System.Threading.SemaphoreSlim" />，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是-1 毫秒，表示无限期超时大于非负数字 <see cref="F:System.Int32.MaxValue" />。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  SemaphoreSlim 实例已释放<paramref name="." /><paramref name="-or-" /><see cref="T:System.Threading.CancellationTokenSource" /> 创建 <paramref name="cancellationToken" /> 被释放。
                </exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>
              阻止当前线程，直至它可进入 <see cref="T:System.Threading.SemaphoreSlim" /> 为止，并使用 32 位带符号整数来指定超时，同时观察 <see cref="T:System.Threading.CancellationToken" />。
            </summary>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。
              </param>
      <param name="cancellationToken">
                要观察的 <see cref="T:System.Threading.CancellationToken" />。
              </param>
      <returns>
              如果当前线程成功进入 <see cref="T:System.Threading.SemaphoreSlim" />，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="T:System.Threading.SemaphoreSlim" /> 实例已被释放，则 <see cref="T:System.Threading.CancellationTokenSource" /> 创建 <paramref name="cancellationToken" /> 已被释放。
                </exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)">
      <summary>
              阻止当前线程，直至它可进入 <see cref="T:System.Threading.SemaphoreSlim" /> 为止，同时使用 <see cref="T:System.TimeSpan" /> 来指定超时。
            </summary>
      <param name="timeout">
                表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。
              </param>
      <returns>
              如果当前线程成功进入 <see cref="T:System.Threading.SemaphoreSlim" />，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是-1 毫秒，表示无限期超时大于非负数字 <see cref="F:System.Int32.MaxValue" />。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  SemaphoreSlim 实例已释放<paramref name="." /></exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Int32)">
      <summary>
              阻止当前线程，直至它可进入 <see cref="T:System.Threading.SemaphoreSlim" /> 为止，同时使用 32 位带符号整数来指定超时。
            </summary>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。
              </param>
      <returns>
              如果当前线程成功进入 <see cref="T:System.Threading.SemaphoreSlim" />，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。
                </exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait">
      <summary>
              阻止当前线程，直至它可进入 <see cref="T:System.Threading.SemaphoreSlim" /> 为止。
            </summary>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)">
      <summary>
              阻止当前线程，直至它可进入 <see cref="T:System.Threading.SemaphoreSlim" /> 为止，同时观察 <see cref="T:System.Threading.CancellationToken" />。
            </summary>
      <param name="cancellationToken">
                要观察的 <see cref="T:System.Threading.CancellationToken" /> 标记。
              </param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                
                  - 或 -
                
                  <see cref="T:System.Threading.CancellationTokenSource" /> 创建<paramref name=" cancellationToken" /> 被释放。
                </exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)">
      <summary>
              在观察 <see cref="T:System.Threading.CancellationToken" /> 时，输入 <see cref="T:System.Threading.SemaphoreSlim" /> 的异步等待，使用 32 位带符号整数度量时间间隔。
            </summary>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。
              </param>
      <param name="cancellationToken">
                要观察的 <see cref="T:System.Threading.CancellationToken" />。
              </param>
      <returns>
              如果当前线程成功输入了 <see cref="T:System.Threading.SemaphoreSlim" />，则为将通过 <see langword="true" /> 的结果一起完成的任务，否则将通过 <see langword="false" /> 的结果完成。
            </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。
                </exception>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。
                </exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync">
      <summary>
              输入 <see cref="T:System.Threading.SemaphoreSlim" /> 的异步等待。
            </summary>
      <returns>
              输入信号量时完成任务。
            </returns>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)">
      <summary>
              输入 <see cref="T:System.Threading.SemaphoreSlim" /> 的异步等待，使用 32 位带符号整数度量时间间隔。
            </summary>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。
              </param>
      <returns>
              如果当前线程成功输入了 <see cref="T:System.Threading.SemaphoreSlim" />，则为将通过 <see langword="true" /> 的结果一起完成的任务，否则将通过 <see langword="false" /> 的结果完成。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。
                </exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)">
      <summary>
              在观察 <see cref="T:System.Threading.CancellationToken" /> 时，输入 <see cref="T:System.Threading.SemaphoreSlim" /> 的异步等待。
            </summary>
      <param name="cancellationToken">
                要观察的 <see cref="T:System.Threading.CancellationToken" /> 标记。
              </param>
      <returns>
              输入信号量时完成任务。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。
                </exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)">
      <summary>
              输入 <see cref="T:System.Threading.SemaphoreSlim" /> 的异步等待，使用 <see cref="T:System.TimeSpan" /> 度量时间间隔。
            </summary>
      <param name="timeout">
                表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。
              </param>
      <returns>
              如果当前线程成功输入了 <see cref="T:System.Threading.SemaphoreSlim" />，则为将通过 <see langword="true" /> 的结果一起完成的任务，否则将通过 <see langword="false" /> 的结果完成。
            </returns>
      <exception cref="T:System.ObjectDisposedException">
                  当前实例已被释放。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 为-1，表示无限期超时非负数 
                
                  - 或 - 
                
                  超时值大于 <see cref="F:System.Int32.MaxValue" />。
                </exception>
    </member>
    <member name="M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>
              在观察 <see cref="T:System.Threading.CancellationToken" /> 时，输入 <see cref="T:System.Threading.SemaphoreSlim" /> 的异步等待，使用 <see cref="T:System.TimeSpan" /> 度量时间间隔。
            </summary>
      <param name="timeout">
                表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。
              </param>
      <param name="cancellationToken">
                要观察的 <see cref="T:System.Threading.CancellationToken" /> 标记。
              </param>
      <returns>
              如果当前线程成功输入了 <see cref="T:System.Threading.SemaphoreSlim" />，则为将通过 <see langword="true" /> 的结果一起完成的任务，否则将通过 <see langword="false" /> 的结果完成。
            </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 为-1，表示无限期超时非负数
                
                  - 或 -
                
                  超时值大于 <see cref="F:System.Int32.MaxValue" />。
                </exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> 已取消。
                </exception>
    </member>
    <member name="T:System.Threading.SendOrPostCallback">
      <summary>
              表示在消息即将被调度到同步上下文时要调用的方法。
            </summary>
      <param name="state">
                传递给委托的对象。
              </param>
    </member>
    <member name="T:System.Threading.SpinLock">
      <summary>
              提供一个相互排斥锁基元，在该基元中，尝试获取锁的线程将在重复检查的循环中等待，直至该锁变为可用为止。
            </summary>
    </member>
    <member name="M:System.Threading.SpinLock.#ctor(System.Boolean)">
      <summary>
              新实例初始化 <see cref="T:System.Threading.SpinLock" /> 跟踪线程 Id，从而提高调试的选项的结构。
            </summary>
      <param name="enableThreadOwnerTracking">
                是否捕获和使用线程 Id 以便进行调试。
              </param>
    </member>
    <member name="M:System.Threading.SpinLock.Enter(System.Boolean@)">
      <summary>
              获取该锁，以可靠的方式，以便即使在方法调用中发生异常 <paramref name="lockTaken" /> 可以可靠地检查，以确定是否已获取锁。
            </summary>
      <param name="lockTaken">
                如果已获取锁; 则为 true否则为 false。
                <paramref name="lockTaken" /> 必须先初始化为 false 之前调用此方法。
              </param>
      <exception cref="T:System.ArgumentException">
        <paramref name="lockTaken" /> 参数必须为 false 可以在调用 Enter 之前进行初始化。
                </exception>
      <exception cref="T:System.Threading.LockRecursionException">
                  线程所有权跟踪已启用，并且当前线程已获取该锁。
                </exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit">
      <summary>
              释放的锁。
            </summary>
      <exception cref="T:System.Threading.SynchronizationLockException">
                  线程所有权跟踪已启用，且当前线程不是此锁的所有者。
                </exception>
    </member>
    <member name="M:System.Threading.SpinLock.Exit(System.Boolean)">
      <summary>
              释放的锁。
            </summary>
      <param name="useMemoryBarrier">
                一个布尔值，该值指示是否应以立即将退出操作发布到其他线程发出内存界定。
              </param>
      <exception cref="T:System.Threading.SynchronizationLockException">
                  线程所有权跟踪已启用，且当前线程不是此锁的所有者。
                </exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeld">
      <summary>
              获取是否由任何线程当前持有此锁。
            </summary>
      <returns>
              如果任何线程中; 当前持有此锁，则 true否则为 false。
            </returns>
    </member>
    <member name="P:System.Threading.SpinLock.IsHeldByCurrentThread">
      <summary>
              获取指示当前线程持有锁。
            </summary>
      <returns>
              默认情况下，锁由当前线程; 如果为 true否则为 false。
            </returns>
      <exception cref="T:System.InvalidOperationException">
                  线程所有权跟踪处于禁用状态。
                </exception>
    </member>
    <member name="P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled">
      <summary>
              获取指示线程所有权跟踪启用此实例。
            </summary>
      <returns>
              如果线程所有权跟踪启用此实例; 则为 true否则为 false。
            </returns>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Boolean@)">
      <summary>
              尝试获取锁，以可靠的方式，以便即使在方法调用中发生异常 <paramref name="lockTaken" /> 可以可靠地检查，以确定是否已获取锁。
            </summary>
      <param name="lockTaken">
                如果已获取锁; 则为 true否则为 false。
                <paramref name="lockTaken" /> 必须先初始化为 false 之前调用此方法。
              </param>
      <exception cref="T:System.ArgumentException">
        <paramref name="lockTaken" /> 参数必须为 false 可以在调用 TryEnter 之前进行初始化。
                </exception>
      <exception cref="T:System.Threading.LockRecursionException">
                  线程所有权跟踪已启用，并且当前线程已获取该锁。
                </exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)">
      <summary>
              尝试获取锁，以可靠的方式，以便即使在方法调用中发生异常 <paramref name="lockTaken" /> 可以可靠地检查，以确定是否已获取锁。
            </summary>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。
              </param>
      <param name="lockTaken">
                如果已获取锁; 则为 true否则为 false。
                <paramref name="lockTaken" /> 必须先初始化为 false 之前调用此方法。
              </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。
                </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="lockTaken" /> 参数必须为 false 可以在调用 TryEnter 之前进行初始化。
                </exception>
      <exception cref="T:System.Threading.LockRecursionException">
                  线程所有权跟踪已启用，并且当前线程已获取该锁。
                </exception>
    </member>
    <member name="M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)">
      <summary>
              尝试获取锁，以可靠的方式，以便即使在方法调用中发生异常 <paramref name="lockTaken" /> 可以可靠地检查，以确定是否已获取锁。
            </summary>
      <param name="timeout">
                表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。
              </param>
      <param name="lockTaken">
                如果已获取锁; 则为 true否则为 false。
                <paramref name="lockTaken" /> 必须先初始化为 false 之前调用此方法。
              </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是-1 毫秒，表示无限期超时大于非负数字 <see cref="F:System.Int32.MaxValue" /> 毫秒为单位。
                </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="lockTaken" /> 参数必须为 false 可以在调用 TryEnter 之前进行初始化。
                </exception>
      <exception cref="T:System.Threading.LockRecursionException">
                  线程所有权跟踪已启用，并且当前线程已获取该锁。
                </exception>
    </member>
    <member name="T:System.Threading.SpinWait">
      <summary>
              为基于自旋的等待提供支持。
            </summary>
    </member>
    <member name="P:System.Threading.SpinWait.Count">
      <summary>
              获取的次数 <see cref="M:System.Threading.SpinWait.SpinOnce" /> 已对此实例调用。
            </summary>
      <returns>
              返回一个整数，表示的次数 <see cref="M:System.Threading.SpinWait.SpinOnce" /> 已对此实例调用。
            </returns>
    </member>
    <member name="P:System.Threading.SpinWait.NextSpinWillYield">
      <summary>
              获取是否确保下次调用 <see cref="M:System.Threading.SpinWait.SpinOnce" /> 会产生处理器，同时触发强制的上下文切换。
            </summary>
      <returns>
              是否确保下次调用 <see cref="M:System.Threading.SpinWait.SpinOnce" /> 会产生处理器，同时触发强制的上下文切换。
            </returns>
    </member>
    <member name="M:System.Threading.SpinWait.Reset">
      <summary>
              将数值调节钮计数器重置。
            </summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinOnce">
      <summary>
              执行单个数值调节钮。
            </summary>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
      <summary>
              旋转直到满足指定的条件。
            </summary>
      <param name="condition">
                直到反复执行的委托返回 true。
              </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="condition" /> 参数为 null。
                </exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
      <summary>
              旋转直到满足指定的条件或指定的超时时间已过期。
            </summary>
      <param name="condition">
                直到反复执行的委托返回 true。
              </param>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。
              </param>
      <returns>
              如果在超时时间; 内不满足该条件为，true否则为 false
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="condition" /> 参数为 null。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。
                </exception>
    </member>
    <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
      <summary>
              旋转直到满足指定的条件或指定的超时时间已过期。
            </summary>
      <param name="condition">
                直到反复执行的委托返回 true。
              </param>
      <param name="timeout">
                一个 <see cref="T:System.TimeSpan" /> ，表示等待毫秒数，或表示-1 毫秒，表示无限期等待一个时间跨度。
              </param>
      <returns>
              如果在超时时间; 内不满足该条件为，true否则为 false
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="condition" /> 参数为 null。
                </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> 是-1 毫秒，表示无限期超时大于非负数字 <see cref="F:System.Int32.MaxValue" />。
                </exception>
    </member>
    <member name="T:System.Threading.SynchronizationContext">
      <summary>
              提供在各种同步模型中传播同步上下文的基本功能。
            </summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.#ctor">
      <summary>
              创建 <see cref="T:System.Threading.SynchronizationContext" /> 类的新实例。
            </summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.CreateCopy">
      <summary>
              在派生类中重写时，创建同步上下文的副本。
            </summary>
      <returns>
              一个新 <see cref="T:System.Threading.SynchronizationContext" /> 对象。
            </returns>
    </member>
    <member name="P:System.Threading.SynchronizationContext.Current">
      <summary>
              获取当前线程的同步上下文。
            </summary>
      <returns>
              一个 <see cref="T:System.Threading.SynchronizationContext" /> 对象，它表示当前同步上下文。
            </returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.IsWaitNotificationRequired">
      <summary>
              确定是否需要等待通知。
            </summary>
      <returns>
              如果需要等待通知，则为 <see langword="true" />；否则为 <see langword="false" />。
            </returns>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationCompleted">
      <summary>
              在派生类中重写时，响应操作已完成的通知。
            </summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.OperationStarted">
      <summary>
              在派生类中重写时，响应操作已开始的通知。
            </summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
      <summary>
              在派生类中重写时，将异步消息分派到同步上下文。
            </summary>
      <param name="d">
                要调用的 <see cref="T:System.Threading.SendOrPostCallback" /> 委托。
              </param>
      <param name="state">
                传递给委托的对象。
              </param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
      <summary>
              在派生类中重写时，将同步消息分派到同步上下文。
            </summary>
      <param name="d">
                要调用的 <see cref="T:System.Threading.SendOrPostCallback" /> 委托。
              </param>
      <param name="state">
                传递给委托的对象。
              </param>
      <exception cref="T:System.NotSupportedException">
                  该方法是在 Windows 应用商店应用程序中调用的。
                   实现 <see cref="T:System.Threading.SynchronizationContext" /> for Windows 应用商店应用程序不支持 <see cref="M:System.Threading.SynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)" /> 方法。
                </exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetSynchronizationContext(System.Threading.SynchronizationContext)">
      <summary>
              设置当前同步上下文。
            </summary>
      <param name="syncContext">
                要设置的 <see cref="T:System.Threading.SynchronizationContext" /> 对象。
              </param>
    </member>
    <member name="M:System.Threading.SynchronizationContext.SetWaitNotificationRequired">
      <summary>
              设置指示需要等待通知的通知，并准备回调方法以使其在发生等待时可以更可靠地被调用。
            </summary>
    </member>
    <member name="M:System.Threading.SynchronizationContext.Wait(System.IntPtr[],System.Boolean,System.Int32)">
      <summary>
              等待指定数组中的任一元素或所有元素接收信号。
            </summary>
      <param name="waitHandles">
                一个类型为 <see cref="T:System.IntPtr" /> 的数组，其中包含本机操作系统句柄。
              </param>
      <param name="waitAll">
                如果等待所有句柄，则为 <see langword="true" />；如果等待任一句柄，则为 <see langword="false" />。
              </param>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。
              </param>
      <returns>
              满足等待的对象的数组索引。
            </returns>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="waitHandles" /> 为 null。
                </exception>
    </member>
    <member name="M:System.Threading.SynchronizationContext.WaitHelper(System.IntPtr[],System.Boolean,System.Int32)">
      <summary>
              用于等待指定数组中的任一元素或所有元素接收信号的 Helper 函数。
            </summary>
      <param name="waitHandles">
                一个类型为 <see cref="T:System.IntPtr" /> 的数组，其中包含本机操作系统句柄。
              </param>
      <param name="waitAll">
                如果等待所有句柄，则为 <see langword="true" />；如果等待任一句柄，则为 <see langword="false" />。
              </param>
      <param name="millisecondsTimeout">
                等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。
              </param>
      <returns>
              满足等待的对象的数组索引。
            </returns>
    </member>
    <member name="T:System.Threading.SynchronizationLockException">
      <summary>
              当某个方法要求调用方拥有给定 Monitor 上的锁并且该方法由不拥有该锁的调用方调用时引发的异常。
            </summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor">
      <summary>
              使用默认属性初始化 <see cref="T:System.Threading.SynchronizationLockException" /> 类的新实例。
            </summary>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String)">
      <summary>
              用指定的错误消息初始化 <see cref="T:System.Threading.SynchronizationLockException" /> 类的新实例。
            </summary>
      <param name="message">
                解释异常原因的错误消息。
              </param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              用序列化数据初始化 <see cref="T:System.Threading.SynchronizationLockException" /> 类的新实例。
            </summary>
      <param name="info">
        <see cref="T:System.Runtime.Serialization.SerializationInfo" />，它保存关于所引发异常的序列化对象数据。
              </param>
      <param name="context">
        <see cref="T:System.Runtime.Serialization.StreamingContext" />，它包含关于源或目标的上下文信息。
              </param>
    </member>
    <member name="M:System.Threading.SynchronizationLockException.#ctor(System.String,System.Exception)">
      <summary>
              使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.Threading.SynchronizationLockException" /> 类的新实例。
            </summary>
      <param name="message">
                解释异常原因的错误消息。
              </param>
      <param name="innerException">
                导致当前异常的异常。
                 如果 <paramref name="innerException" /> 参数不为 <see langword="null" />，则当前异常将在处理内部异常的 <see langword="catch" /> 块中引发。
              </param>
    </member>
  </members>
</doc>